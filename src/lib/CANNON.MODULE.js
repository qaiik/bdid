class ObjectCollisionMatrix{constructor(){this.matrix={}}get(e,t){let{id:i}=e,{id:s}=t;if(s>i){let o=s;s=i,i=o}return`${i}-${s}` in this.matrix}set(e,t,i){let{id:s}=e,{id:o}=t;if(o>s){let n=o;o=s,s=n}i?this.matrix[`${s}-${o}`]=!0:delete this.matrix[`${s}-${o}`]}reset(){this.matrix={}}setNumObjects(e){}}class Mat3{constructor(e){void 0===e&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){let e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){let e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){let t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){void 0===e&&(e=new Vec3);let t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){void 0===t&&(t=new Vec3);let i=this.elements,s=e.x,o=e.y,n=e.z;return t.x=i[0]*s+i[1]*o+i[2]*n,t.y=i[3]*s+i[4]*o+i[5]*n,t.z=i[6]*s+i[7]*o+i[8]*n,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){void 0===t&&(t=new Mat3);let i=this.elements,s=e.elements,o=t.elements,n=i[0],r=i[1],l=i[2],h=i[3],d=i[4],p=i[5],u=i[6],m=i[7],v=i[8],$=s[0],y=s[1],g=s[2],x=s[3],f=s[4],w=s[5],B=s[6],_=s[7],S=s[8];return o[0]=n*$+r*x+l*B,o[1]=n*y+r*f+l*_,o[2]=n*g+r*w+l*S,o[3]=h*$+d*x+p*B,o[4]=h*y+d*f+p*_,o[5]=h*g+d*w+p*S,o[6]=u*$+m*x+v*B,o[7]=u*y+m*f+v*_,o[8]=u*g+m*w+v*S,t}scale(e,t){void 0===t&&(t=new Mat3);let i=this.elements,s=t.elements;for(let o=0;3!==o;o++)s[3*o+0]=e.x*i[3*o+0],s[3*o+1]=e.y*i[3*o+1],s[3*o+2]=e.z*i[3*o+2];return t}solve(e,t){void 0===t&&(t=new Vec3);let i=[],s,o;for(s=0;s<12;s++)i.push(0);for(s=0;s<3;s++)for(o=0;o<3;o++)i[s+4*o]=this.elements[s+3*o];i[3]=e.x,i[7]=e.y,i[11]=e.z;let n=3,r=n,l,h;do{if(0===i[(s=r-n)+4*s]){for(o=s+1;o<r;o++)if(0!==i[s+4*o]){l=4;do h=4-l,i[h+4*s]+=i[h+4*o];while(--l);break}}if(0!==i[s+4*s])for(o=s+1;o<r;o++){let d=i[s+4*o]/i[s+4*s];l=4;do i[(h=4-l)+4*o]=h<=s?0:i[h+4*o]-i[h+4*s]*d;while(--l)}}while(--n);if(t.z=i[11]/i[10],t.y=(i[7]-i[6]*t.z)/i[5],t.x=(i[3]-i[2]*t.z-i[1]*t.y)/i[0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,i){if(void 0===i)return this.elements[t+3*e];this.elements[t+3*e]=i}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";for(let t=0;t<9;t++)e+=this.elements[t]+",";return e}reverse(e){void 0===e&&(e=new Mat3);let t=reverse_eqns,i,s;for(i=0;i<3;i++)for(s=0;s<3;s++)t[i+6*s]=this.elements[i+3*s];t[3]=1,t[9]=0,t[15]=0,t[4]=0,t[10]=1,t[16]=0,t[5]=0,t[11]=0,t[17]=1;let o=3,n=o,r,l;do{if(0===t[(i=n-o)+6*i]){for(s=i+1;s<n;s++)if(0!==t[i+6*s]){r=6;do l=6-r,t[l+6*i]+=t[l+6*s];while(--r);break}}if(0!==t[i+6*i])for(s=i+1;s<n;s++){let h=t[i+6*s]/t[i+6*i];r=6;do t[(l=6-r)+6*s]=l<=i?0:t[l+6*s]-t[l+6*i]*h;while(--r)}}while(--o);i=2;do{s=i-1;do{let d=t[i+6*s]/t[i+6*i];r=6;do t[(l=6-r)+6*s]=t[l+6*s]-t[l+6*i]*d;while(--r)}while(s--)}while(--i);i=2;do{let p=1/t[i+6*i];r=6;do t[(l=6-r)+6*i]=t[l+6*i]*p;while(--r)}while(i--);i=2;do{s=2;do{if(isNaN(l=t[3+s+6*i])||l===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(i,s,l)}while(s--)}while(i--);return e}setRotationFromQuaternion(e){let t=e.x,i=e.y,s=e.z,o=e.w,n=t+t,r=i+i,l=s+s,h=t*n,d=t*r,p=t*l,u=i*r,m=i*l,v=s*l,$=o*n,y=o*r,g=o*l,x=this.elements;return x[0]=1-(u+v),x[1]=d-g,x[2]=p+y,x[3]=d+g,x[4]=1-(h+v),x[5]=m-$,x[6]=p-y,x[7]=m+$,x[8]=1-(h+u),this}transpose(e){void 0===e&&(e=new Mat3);let t=this.elements,i=e.elements,s;return i[0]=t[0],i[4]=t[4],i[8]=t[8],s=t[1],i[1]=t[3],i[3]=s,s=t[2],i[2]=t[6],i[6]=s,s=t[5],i[5]=t[7],i[7]=s,e}}let reverse_eqns=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class Vec3{constructor(e,t,i){void 0===e&&(e=0),void 0===t&&(t=0),void 0===i&&(i=0),this.x=e,this.y=t,this.z=i}cross(e,t){void 0===t&&(t=new Vec3);let i=e.x,s=e.y,o=e.z,n=this.x,r=this.y,l=this.z;return t.x=r*o-l*s,t.y=l*i-n*o,t.z=n*s-r*i,t}set(e,t,i){return this.x=e,this.y=t,this.z=i,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(!t)return new Vec3(this.x+e.x,this.y+e.y,this.z+e.z);t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z}vsub(e,t){if(!t)return new Vec3(this.x-e.x,this.y-e.y,this.z-e.z);t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z}crossmat(){return new Mat3([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){let e=this.x,t=this.y,i=this.z,s=Math.sqrt(e*e+t*t+i*i);if(s>0){let o=1/s;this.x*=o,this.y*=o,this.z*=o}else this.x=0,this.y=0,this.z=0;return s}unit(e){void 0===e&&(e=new Vec3);let t=this.x,i=this.y,s=this.z,o=Math.sqrt(t*t+i*i+s*s);return o>0?(o=1/o,e.x=t*o,e.y=i*o,e.z=s*o):(e.x=1,e.y=0,e.z=0),e}length(){let e=this.x,t=this.y,i=this.z;return Math.sqrt(e*e+t*t+i*i)}lengthSquared(){return this.dot(this)}distanceTo(e){let t=this.x,i=this.y,s=this.z,o=e.x,n=e.y,r=e.z;return Math.sqrt((o-t)*(o-t)+(n-i)*(n-i)+(r-s)*(r-s))}distanceSquared(e){let t=this.x,i=this.y,s=this.z,o=e.x,n=e.y,r=e.z;return(o-t)*(o-t)+(n-i)*(n-i)+(r-s)*(r-s)}scale(e,t){void 0===t&&(t=new Vec3);let i=this.x,s=this.y,o=this.z;return t.x=e*i,t.y=e*s,t.z=e*o,t}vmul(e,t){return void 0===t&&(t=new Vec3),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,i){return void 0===i&&(i=new Vec3),i.x=this.x+e*t.x,i.y=this.y+e*t.y,i.z=this.z+e*t.z,i}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(e){return void 0===e&&(e=new Vec3),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){let i=this.length();if(i>0){let s=Vec3_tangents_n,o=1/i;s.set(this.x*o,this.y*o,this.z*o);let n=Vec3_tangents_randVec;.9>Math.abs(s.x)?(n.set(1,0,0),s.cross(n,e)):(n.set(0,1,0),s.cross(n,e)),s.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,i){let s=this.x,o=this.y,n=this.z;i.x=s+(e.x-s)*t,i.y=o+(e.y-o)*t,i.z=n+(e.z-n)*t}almostEquals(e,t){return void 0===t&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return void 0===e&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(antip_neg),antip_neg.almostEquals(e,t)}clone(){return new Vec3(this.x,this.y,this.z)}}Vec3.ZERO=new Vec3(0,0,0),Vec3.UNIT_X=new Vec3(1,0,0),Vec3.UNIT_Y=new Vec3(0,1,0),Vec3.UNIT_Z=new Vec3(0,0,1);let Vec3_tangents_n=new Vec3,Vec3_tangents_randVec=new Vec3,antip_neg=new Vec3;class AABB{constructor(e){void 0===e&&(e={}),this.lowerBound=new Vec3,this.upperBound=new Vec3,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,i,s){let o=this.lowerBound,n=this.upperBound,r=i;o.copy(e[0]),r&&r.vmult(o,o),n.copy(o);for(let l=1;l<e.length;l++){let h=e[l];r&&(r.vmult(h,tmp$1),h=tmp$1),h.x>n.x&&(n.x=h.x),h.x<o.x&&(o.x=h.x),h.y>n.y&&(n.y=h.y),h.y<o.y&&(o.y=h.y),h.z>n.z&&(n.z=h.z),h.z<o.z&&(o.z=h.z)}return t&&(t.vadd(o,o),t.vadd(n,n)),s&&(o.x-=s,o.y-=s,o.z-=s,n.x+=s,n.y+=s,n.z+=s),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return new AABB().copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){let t=this.lowerBound,i=this.upperBound,s=e.lowerBound,o=e.upperBound,n=s.x<=i.x&&i.x<=o.x||t.x<=o.x&&o.x<=i.x,r=s.y<=i.y&&i.y<=o.y||t.y<=o.y&&o.y<=i.y,l=s.z<=i.z&&i.z<=o.z||t.z<=o.z&&o.z<=i.z;return n&&r&&l}volume(){let e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){let t=this.lowerBound,i=this.upperBound,s=e.lowerBound,o=e.upperBound;return t.x<=s.x&&i.x>=o.x&&t.y<=s.y&&i.y>=o.y&&t.z<=s.z&&i.z>=o.z}getCorners(e,t,i,s,o,n,r,l){let h=this.lowerBound,d=this.upperBound;e.copy(h),t.set(d.x,h.y,h.z),i.set(d.x,d.y,h.z),s.set(h.x,d.y,d.z),o.set(d.x,h.y,d.z),n.set(h.x,d.y,h.z),r.set(h.x,h.y,d.z),l.copy(d)}toLocalFrame(e,t){let i=transformIntoFrame_corners,s=i[0],o=i[1],n=i[2],r=i[3],l=i[4],h=i[5],d=i[6],p=i[7];this.getCorners(s,o,n,r,l,h,d,p);for(let u=0;8!==u;u++){let m=i[u];e.pointToLocal(m,m)}return t.setFromPoints(i)}toWorldFrame(e,t){let i=transformIntoFrame_corners,s=i[0],o=i[1],n=i[2],r=i[3],l=i[4],h=i[5],d=i[6],p=i[7];this.getCorners(s,o,n,r,l,h,d,p);for(let u=0;8!==u;u++){let m=i[u];e.pointToWorld(m,m)}return t.setFromPoints(i)}overlapsRay(e){let{direction:t,from:i}=e,s=1/t.x,o=1/t.y,n=1/t.z,r=(this.lowerBound.x-i.x)*s,l=(this.upperBound.x-i.x)*s,h=(this.lowerBound.y-i.y)*o,d=(this.upperBound.y-i.y)*o,p=(this.lowerBound.z-i.z)*n,u=(this.upperBound.z-i.z)*n,m=Math.min(Math.min(Math.max(r,l),Math.max(h,d)),Math.max(p,u));return!(m<0||Math.max(Math.max(Math.min(r,l),Math.min(h,d)),Math.min(p,u))>m)}}let tmp$1=new Vec3,transformIntoFrame_corners=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3];class ArrayCollisionMatrix{constructor(){this.matrix=[]}get(e,t){let{index:i}=e,{index:s}=t;if(s>i){let o=s;s=i,i=o}return this.matrix[(i*(i+1)>>1)+s-1]}set(e,t,i){let{index:s}=e,{index:o}=t;if(o>s){let n=o;o=s,s=n}this.matrix[(s*(s+1)>>1)+o-1]=i?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class EventTarget{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});let i=this._listeners;return void 0===i[e]&&(i[e]=[]),i[e].includes(t)||i[e].push(t),this}hasEventListener(e,t){if(void 0===this._listeners)return!1;let i=this._listeners;return!!(void 0!==i[e]&&i[e].includes(t))}hasAnyEventListener(e){if(void 0===this._listeners)return!1;let t=this._listeners;return void 0!==t[e]}removeEventListener(e,t){if(void 0===this._listeners)return this;let i=this._listeners;if(void 0===i[e])return this;let s=i[e].indexOf(t);return -1!==s&&i[e].splice(s,1),this}dispatchEvent(e){if(void 0===this._listeners)return this;let t=this._listeners,i=t[e.type];if(void 0!==i){e.target=this;for(let s=0,o=i.length;s<o;s++)i[s].call(this,e)}return this}}class Quaternion{constructor(e,t,i,s){void 0===e&&(e=0),void 0===t&&(t=0),void 0===i&&(i=0),void 0===s&&(s=1),this.x=e,this.y=t,this.z=i,this.w=s}set(e,t,i,s){return this.x=e,this.y=t,this.z=i,this.w=s,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){let i=Math.sin(.5*t);return this.x=e.x*i,this.y=e.y*i,this.z=e.z*i,this.w=Math.cos(.5*t),this}toAxisAngle(e){void 0===e&&(e=new Vec3),this.normalize();let t=2*Math.acos(this.w),i=Math.sqrt(1-this.w*this.w);return i<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/i,e.y=this.y/i,e.z=this.z/i),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){let i=sfv_t1;e.tangents(i,sfv_t2),this.setFromAxisAngle(i,Math.PI)}else{let s=e.cross(t);this.x=s.x,this.y=s.y,this.z=s.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){void 0===t&&(t=new Quaternion);let i=this.x,s=this.y,o=this.z,n=this.w,r=e.x,l=e.y,h=e.z,d=e.w;return t.x=i*d+n*r+s*h-o*l,t.y=s*d+n*l+o*r-i*h,t.z=o*d+n*h+i*l-s*r,t.w=n*d-i*r-s*l-o*h,t}inverse(e){void 0===e&&(e=new Quaternion);let t=this.x,i=this.y,s=this.z,o=this.w;this.conjugate(e);let n=1/(t*t+i*i+s*s+o*o);return e.x*=n,e.y*=n,e.z*=n,e.w*=n,e}conjugate(e){return void 0===e&&(e=new Quaternion),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){let e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){void 0===t&&(t=new Vec3);let i=e.x,s=e.y,o=e.z,n=this.x,r=this.y,l=this.z,h=this.w,d=h*i+r*o-l*s,p=h*s+l*i-n*o,u=h*o+n*s-r*i,m=-n*i-r*s-l*o;return t.x=d*h+-(m*n)+-(p*l)- -(u*r),t.y=p*h+-(m*r)+-(u*n)- -(d*l),t.z=u*h+-(m*l)+-(d*r)- -(p*n),t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){void 0===t&&(t="YZX");let i,s,o,n=this.x,r=this.y,l=this.z,h=this.w;if("YZX"===t){let d=n*r+l*h;if(d>.499&&(i=2*Math.atan2(n,h),s=Math.PI/2,o=0),d<-.499&&(i=-2*Math.atan2(n,h),s=-Math.PI/2,o=0),void 0===i){let p=l*l;i=Math.atan2(2*r*h-2*n*l,1-2*(r*r)-2*p),s=Math.asin(2*d),o=Math.atan2(2*n*h-2*r*l,1-2*(n*n)-2*p)}}else throw Error(`Euler order ${t} not supported yet.`);e.y=i,e.z=s,e.x=o}setFromEuler(e,t,i,s){void 0===s&&(s="XYZ");let o=Math.cos(e/2),n=Math.cos(t/2),r=Math.cos(i/2),l=Math.sin(e/2),h=Math.sin(t/2),d=Math.sin(i/2);return"XYZ"===s?(this.x=l*n*r+o*h*d,this.y=o*h*r-l*n*d,this.z=o*n*d+l*h*r,this.w=o*n*r-l*h*d):"YXZ"===s?(this.x=l*n*r+o*h*d,this.y=o*h*r-l*n*d,this.z=o*n*d-l*h*r,this.w=o*n*r+l*h*d):"ZXY"===s?(this.x=l*n*r-o*h*d,this.y=o*h*r+l*n*d,this.z=o*n*d+l*h*r,this.w=o*n*r-l*h*d):"ZYX"===s?(this.x=l*n*r-o*h*d,this.y=o*h*r+l*n*d,this.z=o*n*d-l*h*r,this.w=o*n*r+l*h*d):"YZX"===s?(this.x=l*n*r+o*h*d,this.y=o*h*r+l*n*d,this.z=o*n*d-l*h*r,this.w=o*n*r-l*h*d):"XZY"===s&&(this.x=l*n*r-o*h*d,this.y=o*h*r-l*n*d,this.z=o*n*d+l*h*r,this.w=o*n*r+l*h*d),this}clone(){return new Quaternion(this.x,this.y,this.z,this.w)}slerp(e,t,i){void 0===i&&(i=new Quaternion);let s=this.x,o=this.y,n=this.z,r=this.w,l=e.x,h=e.y,d=e.z,p=e.w,u,m,v,$,y;return(m=s*l+o*h+n*d+r*p)<0&&(m=-m,l=-l,h=-h,d=-d,p=-p),1-m>1e-6?($=Math.sin((1-t)*u)/(v=Math.sin(u=Math.acos(m))),y=Math.sin(t*u)/v):($=1-t,y=t),i.x=$*s+y*l,i.y=$*o+y*h,i.z=$*n+y*d,i.w=$*r+y*p,i}integrate(e,t,i,s){void 0===s&&(s=new Quaternion);let o=e.x*i.x,n=e.y*i.y,r=e.z*i.z,l=this.x,h=this.y,d=this.z,p=this.w,u=.5*t;return s.x+=u*(o*p+n*d-r*h),s.y+=u*(n*p+r*l-o*d),s.z+=u*(r*p+o*h-n*l),s.w+=u*(-o*l-n*h-r*d),s}}let sfv_t1=new Vec3,sfv_t2=new Vec3,SHAPE_TYPES={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class Shape{constructor(e){void 0===e&&(e={}),this.id=Shape.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=!e.collisionResponse||e.collisionResponse,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(e,t){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(e,t,i,s){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}Shape.idCounter=0,Shape.types=SHAPE_TYPES;class Transform{constructor(e){void 0===e&&(e={}),this.position=new Vec3,this.quaternion=new Quaternion,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return Transform.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return Transform.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return void 0===t&&(t=new Vec3),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,i,s){return void 0===s&&(s=new Vec3),i.vsub(e,s),t.conjugate(tmpQuat$1),tmpQuat$1.vmult(s,s),s}static pointToWorldFrame(e,t,i,s){return void 0===s&&(s=new Vec3),t.vmult(i,s),s.vadd(e,s),s}static vectorToWorldFrame(e,t,i){return void 0===i&&(i=new Vec3),e.vmult(t,i),i}static vectorToLocalFrame(e,t,i,s){return void 0===s&&(s=new Vec3),t.w*=-1,t.vmult(i,s),t.w*=-1,s}}let tmpQuat$1=new Quaternion;class ConvexPolyhedron extends Shape{constructor(e){void 0===e&&(e={});let{vertices:t=[],faces:i=[],normals:s=[],axes:o,boundingSphereRadius:n}=e;super({type:Shape.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=i,this.faceNormals=s,0===this.faceNormals.length&&this.computeNormals(),n?this.boundingSphereRadius=n:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=o?o.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){let e=this.faces,t=this.vertices,i=this.uniqueEdges;i.length=0;let s=new Vec3;for(let o=0;o!==e.length;o++){let n=e[o],r=n.length;for(let l=0;l!==r;l++){let h=(l+1)%r;t[n[l]].vsub(t[n[h]],s),s.normalize();let d=!1;for(let p=0;p!==i.length;p++)if(i[p].almostEquals(s)||i[p].almostEquals(s)){d=!0;break}d||i.push(s.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let t=0;t<this.faces[e].length;t++)if(!this.vertices[this.faces[e][t]])throw Error(`Vertex ${this.faces[e][t]} not found!`);let i=this.faceNormals[e]||new Vec3;this.getFaceNormal(e,i),i.negate(i),this.faceNormals[e]=i;let s=this.vertices[this.faces[e][0]];if(0>i.dot(s)){console.error(`.faceNormals[${e}] = Vec3(${i.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let o=0;o<this.faces[e].length;o++)console.warn(`.vertices[${this.faces[e][o]}] = Vec3(${this.vertices[this.faces[e][o]].toString()})`)}}}getFaceNormal(e,t){let i=this.faces[e],s=this.vertices[i[0]],o=this.vertices[i[1]],n=this.vertices[i[2]];ConvexPolyhedron.computeNormal(s,o,n,t)}static computeNormal(e,t,i,s){let o=new Vec3,n=new Vec3;t.vsub(e,n),i.vsub(t,o),o.cross(n,s),s.isZero()||s.normalize()}clipAgainstHull(e,t,i,s,o,n,r,l,h){let d=new Vec3,p=-1,u=-Number.MAX_VALUE;for(let m=0;m<i.faces.length;m++){d.copy(i.faceNormals[m]),o.vmult(d,d);let v=d.dot(n);v>u&&(u=v,p=m)}let $=[];for(let y=0;y<i.faces[p].length;y++){let g=i.vertices[i.faces[p][y]],x=new Vec3;x.copy(g),o.vmult(x,x),s.vadd(x,x),$.push(x)}p>=0&&this.clipFaceAgainstHull(n,e,t,$,r,l,h)}findSeparatingAxis(e,t,i,s,o,n,r,l){let h=new Vec3,d=new Vec3,p=new Vec3,u=new Vec3,m=new Vec3,v=new Vec3,$=Number.MAX_VALUE;if(this.uniqueAxes)for(let y=0;y!==this.uniqueAxes.length;y++){i.vmult(this.uniqueAxes[y],h);let g=this.testSepAxis(h,e,t,i,s,o);if(!1===g)return!1;g<$&&($=g,n.copy(h))}else{let x=r?r.length:this.faces.length;for(let f=0;f<x;f++){let w=r?r[f]:f;h.copy(this.faceNormals[w]),i.vmult(h,h);let B=this.testSepAxis(h,e,t,i,s,o);if(!1===B)return!1;B<$&&($=B,n.copy(h))}}if(e.uniqueAxes)for(let _=0;_!==e.uniqueAxes.length;_++){o.vmult(e.uniqueAxes[_],d);let S=this.testSepAxis(d,e,t,i,s,o);if(!1===S)return!1;S<$&&($=S,n.copy(d))}else{let V=l?l.length:e.faces.length;for(let A=0;A<V;A++){let E=l?l[A]:A;d.copy(e.faceNormals[E]),o.vmult(d,d);let C=this.testSepAxis(d,e,t,i,s,o);if(!1===C)return!1;C<$&&($=C,n.copy(d))}}for(let T=0;T!==this.uniqueEdges.length;T++){i.vmult(this.uniqueEdges[T],u);for(let P=0;P!==e.uniqueEdges.length;P++)if(o.vmult(e.uniqueEdges[P],m),u.cross(m,v),!v.almostZero()){v.normalize();let I=this.testSepAxis(v,e,t,i,s,o);if(!1===I)return!1;I<$&&($=I,n.copy(v))}}return s.vsub(t,p),p.dot(n)>0&&n.negate(n),!0}testSepAxis(e,t,i,s,o,n){ConvexPolyhedron.project(this,e,i,s,maxminA),ConvexPolyhedron.project(t,e,o,n,maxminB);let r=maxminA[0],l=maxminA[1],h=maxminB[0],d=maxminB[1];if(r<d||h<l)return!1;let p=r-d,u=h-l;return p<u?p:u}calculateLocalInertia(e,t){let i=new Vec3,s=new Vec3;this.computeLocalAABB(s,i);let o=i.x-s.x,n=i.y-s.y,r=i.z-s.z;t.x=1/12*e*(2*n*2*n+2*r*2*r),t.y=1/12*e*(2*o*2*o+2*r*2*r),t.z=1/12*e*(2*n*2*n+2*o*2*o)}getPlaneConstantOfFace(e){let t=this.faces[e],i=this.faceNormals[e],s=this.vertices[t[0]],o=-i.dot(s);return o}clipFaceAgainstHull(e,t,i,s,o,n,r){let l=new Vec3,h=new Vec3,d=new Vec3,p=new Vec3,u=new Vec3,m=new Vec3,v=new Vec3,$=new Vec3,y=s,g=[],x=-1,f=Number.MAX_VALUE;for(let w=0;w<this.faces.length;w++){l.copy(this.faceNormals[w]),i.vmult(l,l);let B=l.dot(e);B<f&&(f=B,x=w)}if(x<0)return;let _=this.faces[x];_.connectedFaces=[];for(let S=0;S<this.faces.length;S++)for(let V=0;V<this.faces[S].length;V++)-1!==_.indexOf(this.faces[S][V])&&S!==x&&-1===_.connectedFaces.indexOf(S)&&_.connectedFaces.push(S);let A=_.length;for(let E=0;E<A;E++){let C=this.vertices[_[E]],T=this.vertices[_[(E+1)%A]];C.vsub(T,h),d.copy(h),i.vmult(d,d),t.vadd(d,d),p.copy(this.faceNormals[x]),i.vmult(p,p),t.vadd(p,p),d.cross(p,u),u.negate(u),m.copy(C),i.vmult(m,m),t.vadd(m,m);let P=_.connectedFaces[E];v.copy(this.faceNormals[P]);let I=this.getPlaneConstantOfFace(P);$.copy(v),i.vmult($,$);let F=I-$.dot(t);for(this.clipFaceAgainstPlane(y,g,$,F);y.length;)y.shift();for(;g.length;)y.push(g.shift())}v.copy(this.faceNormals[x]);let R=this.getPlaneConstantOfFace(x);$.copy(v),i.vmult($,$);let z=R-$.dot(t);for(let q=0;q<y.length;q++){let N=$.dot(y[q])+z;if(N<=o&&(console.log(`clamped: depth=${N} to minDist=${o}`),N=o),N<=n){let L=y[q];if(N<=1e-6){let W={point:L,normal:$,depth:N};r.push(W)}}}}clipFaceAgainstPlane(e,t,i,s){let o,n,r=e.length;if(r<2)return t;let l=e[e.length-1],h=e[0];o=i.dot(l)+s;for(let d=0;d<r;d++){if(h=e[d],n=i.dot(h)+s,o<0){if(n<0){let p=new Vec3;p.copy(h),t.push(p)}else{let u=new Vec3;l.lerp(h,o/(o-n),u),t.push(u)}}else if(n<0){let m=new Vec3;l.lerp(h,o/(o-n),m),t.push(m),t.push(h)}l=h,o=n}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new Vec3);let i=this.vertices,s=this.worldVertices;for(let o=0;o!==this.vertices.length;o++)t.vmult(i[o],s[o]),e.vadd(s[o],s[o]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){let i=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let s=0;s<this.vertices.length;s++){let o=i[s];o.x<e.x?e.x=o.x:o.x>t.x&&(t.x=o.x),o.y<e.y?e.y=o.y:o.y>t.y&&(t.y=o.y),o.z<e.z?e.z=o.z:o.z>t.z&&(t.z=o.z)}}computeWorldFaceNormals(e){let t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new Vec3);let i=this.faceNormals,s=this.worldFaceNormals;for(let o=0;o!==t;o++)e.vmult(i[o],s[o]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0,t=this.vertices;for(let i=0;i!==t.length;i++){let s=t[i].lengthSquared();s>e&&(e=s)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,i,s){let o=this.vertices,n,r,l,h,d,p,u=new Vec3;for(let m=0;m<o.length;m++){u.copy(o[m]),t.vmult(u,u),e.vadd(u,u);let v=u;(void 0===n||v.x<n)&&(n=v.x),(void 0===h||v.x>h)&&(h=v.x),(void 0===r||v.y<r)&&(r=v.y),(void 0===d||v.y>d)&&(d=v.y),(void 0===l||v.z<l)&&(l=v.z),(void 0===p||v.z>p)&&(p=v.z)}i.set(n,r,l),s.set(h,d,p)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){void 0===e&&(e=new Vec3);let t=this.vertices;for(let i=0;i<t.length;i++)e.vadd(t[i],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){let i=this.vertices.length,s=this.vertices;if(t){for(let o=0;o<i;o++){let n=s[o];t.vmult(n,n)}for(let r=0;r<this.faceNormals.length;r++){let l=this.faceNormals[r];t.vmult(l,l)}}if(e)for(let h=0;h<i;h++){let d=s[h];d.vadd(e,d)}}pointIsInside(e){let t=this.vertices,i=this.faces,s=this.faceNormals,o=new Vec3;this.getAveragePointLocal(o);for(let n=0;n<this.faces.length;n++){let r=s[n],l=t[i[n][0]],h=new Vec3;e.vsub(l,h);let d=r.dot(h),p=new Vec3;o.vsub(l,p);let u=r.dot(p);if(d<0&&u>0||d>0&&u<0)return!1}return -1}static project(e,t,i,s,o){let n=e.vertices.length,r=project_localAxis,l=0,h=0,d=project_localOrigin,p=e.vertices;d.setZero(),Transform.vectorToLocalFrame(i,s,t,r),Transform.pointToLocalFrame(i,s,d,d);let u=d.dot(r);h=l=p[0].dot(r);for(let m=1;m<n;m++){let v=p[m].dot(r);v>l&&(l=v),v<h&&(h=v)}if((h-=u)>(l-=u)){let $=h;h=l,l=$}o[0]=l,o[1]=h}}let maxminA=[],maxminB=[],project_worldVertex=new Vec3,project_localAxis=new Vec3,project_localOrigin=new Vec3;class Box extends Shape{constructor(e){super({type:Shape.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){let e=this.halfExtents.x,t=this.halfExtents.y,i=this.halfExtents.z,s=Vec3,o=[new s(-e,-t,-i),new s(e,-t,-i),new s(e,t,-i),new s(-e,t,-i),new s(-e,-t,i),new s(e,-t,i),new s(e,t,i),new s(-e,t,i)],n=[new s(0,0,1),new s(0,1,0),new s(1,0,0)],r=new ConvexPolyhedron({vertices:o,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:n});this.convexPolyhedronRepresentation=r,r.material=this.material}calculateLocalInertia(e,t){return void 0===t&&(t=new Vec3),Box.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,i){let s=e;i.x=1/12*t*(2*s.y*2*s.y+2*s.z*2*s.z),i.y=1/12*t*(2*s.x*2*s.x+2*s.z*2*s.z),i.z=1/12*t*(2*s.y*2*s.y+2*s.x*2*s.x)}getSideNormals(e,t){let i=e,s=this.halfExtents;if(i[0].set(s.x,0,0),i[1].set(0,s.y,0),i[2].set(0,0,s.z),i[3].set(-s.x,0,0),i[4].set(0,-s.y,0),i[5].set(0,0,-s.z),void 0!==t)for(let o=0;o!==i.length;o++)t.vmult(i[o],i[o]);return i}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,i){let s=this.halfExtents,o=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let n=0;n<o.length;n++)worldCornerTempPos.set(o[n][0],o[n][1],o[n][2]),t.vmult(worldCornerTempPos,worldCornerTempPos),e.vadd(worldCornerTempPos,worldCornerTempPos),i(worldCornerTempPos.x,worldCornerTempPos.y,worldCornerTempPos.z)}calculateWorldAABB(e,t,i,s){let o=this.halfExtents;worldCornersTemp[0].set(o.x,o.y,o.z),worldCornersTemp[1].set(-o.x,o.y,o.z),worldCornersTemp[2].set(-o.x,-o.y,o.z),worldCornersTemp[3].set(-o.x,-o.y,-o.z),worldCornersTemp[4].set(o.x,-o.y,-o.z),worldCornersTemp[5].set(o.x,o.y,-o.z),worldCornersTemp[6].set(-o.x,o.y,-o.z),worldCornersTemp[7].set(o.x,-o.y,o.z);let n=worldCornersTemp[0];t.vmult(n,n),e.vadd(n,n),s.copy(n),i.copy(n);for(let r=1;r<8;r++){let l=worldCornersTemp[r];t.vmult(l,l),e.vadd(l,l);let h=l.x,d=l.y,p=l.z;h>s.x&&(s.x=h),d>s.y&&(s.y=d),p>s.z&&(s.z=p),h<i.x&&(i.x=h),d<i.y&&(i.y=d),p<i.z&&(i.z=p)}}}let worldCornerTempPos=new Vec3,worldCornersTemp=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3],BODY_TYPES={DYNAMIC:1,STATIC:2,KINEMATIC:4},BODY_SLEEP_STATES={AWAKE:0,SLEEPY:1,SLEEPING:2};class Body extends EventTarget{constructor(e){void 0===e&&(e={}),super(),this.id=Body.idCounter++,this.index=-1,this.world=null,this.vlambda=new Vec3,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof e.collisionResponse||e.collisionResponse,this.position=new Vec3,this.previousPosition=new Vec3,this.interpolatedPosition=new Vec3,this.initPosition=new Vec3,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new Vec3,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new Vec3,this.force=new Vec3;let t="number"==typeof e.mass?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=t<=0?Body.STATIC:Body.DYNAMIC,typeof e.type==typeof Body.STATIC&&(this.type=e.type),this.allowSleep=void 0===e.allowSleep||e.allowSleep,this.sleepState=Body.AWAKE,this.sleepSpeedLimit=void 0!==e.sleepSpeedLimit?e.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==e.sleepTimeLimit?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new Vec3,this.quaternion=new Quaternion,this.initQuaternion=new Quaternion,this.previousQuaternion=new Quaternion,this.interpolatedQuaternion=new Quaternion,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new Vec3,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new Vec3,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new Vec3,this.invInertia=new Vec3,this.invInertiaWorld=new Mat3,this.invMassSolve=0,this.invInertiaSolve=new Vec3,this.invInertiaWorldSolve=new Mat3,this.fixedRotation=void 0!==e.fixedRotation&&e.fixedRotation,this.angularDamping=void 0!==e.angularDamping?e.angularDamping:.01,this.linearFactor=new Vec3(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new Vec3(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new AABB,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new Vec3,this.isTrigger=Boolean(e.isTrigger),e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){let e=this.sleepState;this.sleepState=Body.AWAKE,this.wakeUpAfterNarrowphase=!1,e===Body.SLEEPING&&this.dispatchEvent(Body.wakeupEvent)}sleep(){this.sleepState=Body.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){let t=this.sleepState,i=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),s=this.sleepSpeedLimit**2;t===Body.AWAKE&&i<s?(this.sleepState=Body.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(Body.sleepyEvent)):t===Body.SLEEPY&&i>s?this.wakeUp():t===Body.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(Body.sleepEvent))}}updateSolveMassProperties(){this.sleepState===Body.SLEEPING||this.type===Body.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return void 0===t&&(t=new Vec3),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return void 0===t&&(t=new Vec3),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return void 0===t&&(t=new Vec3),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return void 0===t&&(t=new Vec3),this.quaternion.vmult(e,t),t}addShape(e,t,i){let s=new Vec3,o=new Quaternion;return t&&s.copy(t),i&&o.copy(i),this.shapes.push(e),this.shapeOffsets.push(s),this.shapeOrientations.push(o),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){let t=this.shapes.indexOf(e);return -1===t?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){let e=this.shapes,t=this.shapeOffsets,i=e.length,s=0;for(let o=0;o!==i;o++){let n=e[o];n.updateBoundingSphereRadius();let r=t[o].length(),l=n.boundingSphereRadius;r+l>s&&(s=r+l)}this.boundingRadius=s}updateAABB(){let e=this.shapes,t=this.shapeOffsets,i=this.shapeOrientations,s=e.length,o=tmpVec,n=tmpQuat,r=this.quaternion,l=this.aabb,h=updateAABB_shapeAABB;for(let d=0;d!==s;d++){let p=e[d];r.vmult(t[d],o),o.vadd(this.position,o),r.mult(i[d],n),p.calculateWorldAABB(o,n,h.lowerBound,h.upperBound),0===d?l.copy(h):l.extend(h)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){let t=this.invInertia;if(t.x!==t.y||t.y!==t.z||e){let i=uiw_m1,s=uiw_m2;i.setRotationFromQuaternion(this.quaternion),i.transpose(s),i.scale(t,i),i.mmult(s,this.invInertiaWorld)}}applyForce(e,t){if(void 0===t&&(t=new Vec3),this.type!==Body.DYNAMIC)return;this.sleepState===Body.SLEEPING&&this.wakeUp();let i=Body_applyForce_rotForce;t.cross(e,i),this.force.vadd(e,this.force),this.torque.vadd(i,this.torque)}applyLocalForce(e,t){if(void 0===t&&(t=new Vec3),this.type!==Body.DYNAMIC)return;let i=Body_applyLocalForce_worldForce,s=Body_applyLocalForce_relativePointWorld;this.vectorToWorldFrame(e,i),this.vectorToWorldFrame(t,s),this.applyForce(i,s)}applyTorque(e){this.type===Body.DYNAMIC&&(this.sleepState===Body.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(void 0===t&&(t=new Vec3),this.type!==Body.DYNAMIC)return;this.sleepState===Body.SLEEPING&&this.wakeUp();let i=t,s=Body_applyImpulse_velo;s.copy(e),s.scale(this.invMass,s),this.velocity.vadd(s,this.velocity);let o=Body_applyImpulse_rotVelo;i.cross(e,o),this.invInertiaWorld.vmult(o,o),this.angularVelocity.vadd(o,this.angularVelocity)}applyLocalImpulse(e,t){if(void 0===t&&(t=new Vec3),this.type!==Body.DYNAMIC)return;let i=Body_applyLocalImpulse_worldImpulse,s=Body_applyLocalImpulse_relativePoint;this.vectorToWorldFrame(e,i),this.vectorToWorldFrame(t,s),this.applyImpulse(i,s)}updateMassProperties(){let e=Body_updateMassProperties_halfExtents;this.invMass=this.mass>0?1/this.mass:0;let t=this.inertia,i=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Box.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!i?1/t.x:0,t.y>0&&!i?1/t.y:0,t.z>0&&!i?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){let i=new Vec3;return e.vsub(this.position,i),this.angularVelocity.cross(i,t),this.velocity.vadd(t,t),t}integrate(e,t,i){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===Body.DYNAMIC||this.type===Body.KINEMATIC)||this.sleepState===Body.SLEEPING)return;let s=this.velocity,o=this.angularVelocity,n=this.position,r=this.force,l=this.torque,h=this.quaternion,d=this.invMass,p=this.invInertiaWorld,u=this.linearFactor,m=d*e;s.x+=r.x*m*u.x,s.y+=r.y*m*u.y,s.z+=r.z*m*u.z;let v=p.elements,$=this.angularFactor,y=l.x*$.x,g=l.y*$.y,x=l.z*$.z;o.x+=e*(v[0]*y+v[1]*g+v[2]*x),o.y+=e*(v[3]*y+v[4]*g+v[5]*x),o.z+=e*(v[6]*y+v[7]*g+v[8]*x),n.x+=s.x*e,n.y+=s.y*e,n.z+=s.z*e,h.integrate(this.angularVelocity,e,this.angularFactor,h),t&&(i?h.normalizeFast():h.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}Body.idCounter=0,Body.COLLIDE_EVENT_NAME="collide",Body.DYNAMIC=BODY_TYPES.DYNAMIC,Body.STATIC=BODY_TYPES.STATIC,Body.KINEMATIC=BODY_TYPES.KINEMATIC,Body.AWAKE=BODY_SLEEP_STATES.AWAKE,Body.SLEEPY=BODY_SLEEP_STATES.SLEEPY,Body.SLEEPING=BODY_SLEEP_STATES.SLEEPING,Body.wakeupEvent={type:"wakeup"},Body.sleepyEvent={type:"sleepy"},Body.sleepEvent={type:"sleep"};let tmpVec=new Vec3,tmpQuat=new Quaternion,updateAABB_shapeAABB=new AABB,uiw_m1=new Mat3,uiw_m2=new Mat3,uiw_m3=new Mat3,Body_applyForce_rotForce=new Vec3,Body_applyLocalForce_worldForce=new Vec3,Body_applyLocalForce_relativePointWorld=new Vec3,Body_applyImpulse_velo=new Vec3,Body_applyImpulse_rotVelo=new Vec3,Body_applyLocalImpulse_worldImpulse=new Vec3,Body_applyLocalImpulse_relativePoint=new Vec3,Body_updateMassProperties_halfExtents=new Vec3;class Broadphase{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,i){throw Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return(e.collisionFilterGroup&t.collisionFilterMask)!=0&&(t.collisionFilterGroup&e.collisionFilterMask)!=0&&((e.type&Body.STATIC)==0&&e.sleepState!==Body.SLEEPING||(t.type&Body.STATIC)==0&&t.sleepState!==Body.SLEEPING)}intersectionTest(e,t,i,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,i,s):this.doBoundingSphereBroadphase(e,t,i,s)}doBoundingSphereBroadphase(e,t,i,s){let o=Broadphase_collisionPairs_r;t.position.vsub(e.position,o);let n=(e.boundingRadius+t.boundingRadius)**2,r=o.lengthSquared();r<n&&(i.push(e),s.push(t))}doBoundingBoxBroadphase(e,t,i,s){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(i.push(e),s.push(t))}makePairsUnique(e,t){let i=Broadphase_makePairsUnique_temp,s=Broadphase_makePairsUnique_p1,o=Broadphase_makePairsUnique_p2,n=e.length;for(let r=0;r!==n;r++)s[r]=e[r],o[r]=t[r];e.length=0,t.length=0;for(let l=0;l!==n;l++){let h=s[l].id,d=o[l].id,p=h<d?`${h},${d}`:`${d},${h}`;i[p]=l,i.keys.push(p)}for(let u=0;u!==i.keys.length;u++){let m=i.keys.pop(),v=i[m];e.push(s[v]),t.push(o[v]),delete i[m]}}setWorld(e){}static boundingSphereCheck(e,t){let i=new Vec3;e.position.vsub(t.position,i);let s=e.shapes[0],o=t.shapes[0];return Math.pow(s.boundingSphereRadius+o.boundingSphereRadius,2)>i.lengthSquared()}aabbQuery(e,t,i){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}let Broadphase_collisionPairs_r=new Vec3;new Vec3,new Quaternion,new Vec3;let Broadphase_makePairsUnique_temp={keys:[]},Broadphase_makePairsUnique_p1=[],Broadphase_makePairsUnique_p2=[];new Vec3;class GridBroadphase extends Broadphase{constructor(e,t,i,s,o){void 0===e&&(e=new Vec3(100,100,100)),void 0===t&&(t=new Vec3(-100,-100,-100)),void 0===i&&(i=10),void 0===s&&(s=10),void 0===o&&(o=10),super(),this.nx=i,this.ny=s,this.nz=o,this.aabbMin=e,this.aabbMax=t;let n=this.nx*this.ny*this.nz;if(n<=0)throw"GridBroadphase: Each dimension's n must be >0";this.bins=[],this.binLengths=[],this.bins.length=n,this.binLengths.length=n;for(let r=0;r<n;r++)this.bins[r]=[],this.binLengths[r]=0}collisionPairs(e,t,i){let s=e.bodies.length,o=e.bodies,n=this.aabbMax,r=this.aabbMin,l=this.nx,h=this.ny,d=this.nz,p=h*d,u=d,m=n.x,v=n.y,$=n.z,y=r.x,g=r.y,x=r.z,f=l/(m-y),w=h/(v-g),B=d/($-x),_=(m-y)/l,S=(v-g)/h,V=($-x)/d,A=.5*Math.sqrt(_*_+S*S+V*V),E=Shape.types,C=E.SPHERE,T=E.PLANE;E.BOX,E.COMPOUND,E.CONVEXPOLYHEDRON;let P=this.bins,I=this.binLengths,F=this.bins.length;for(let R=0;R!==F;R++)I[R]=0;let z=Math.ceil;function q(e,t,i,s,o,n,r){let m=(e-y)*f|0,v=(t-g)*w|0,$=(i-x)*B|0,_=z((s-y)*f),S=z((o-g)*w),V=z((n-x)*B);m<0?m=0:m>=l&&(m=l-1),v<0?v=0:v>=h&&(v=h-1),$<0?$=0:$>=d&&($=d-1),_<0?_=0:_>=l&&(_=l-1),S<0?S=0:S>=h&&(S=h-1),V<0?V=0:V>=d&&(V=d-1),m*=p,v*=u,$*=1,_*=p,S*=u,V*=1;for(let A=m;A<=_;A+=p)for(let E=v;E<=S;E+=u)for(let C=$;C<=V;C+=1){let T=A+E+C;P[T][I[T]++]=r}}for(let N=0;N!==s;N++){let L=o[N],W=L.shapes[0];switch(W.type){case C:{let O=W,M=L.position.x,j=L.position.y,H=L.position.z,k=O.radius;q(M-k,j-k,H-k,M+k,j+k,H+k,L);break}case T:{let D=W;D.worldNormalNeedsUpdate&&D.computeWorldNormal(L.quaternion);let Y=D.worldNormal,U=y+.5*_-L.position.x,G=g+.5*S-L.position.y,X=x+.5*V-L.position.z,Q=GridBroadphase_collisionPairs_d;Q.set(U,G,X);for(let K=0,Z=0;K!==l;K++,Z+=p,Q.y=G,Q.x+=_)for(let J=0,ee=0;J!==h;J++,ee+=u,Q.z=X,Q.y+=S)for(let et=0,ei=0;et!==d;et++,ei+=1,Q.z+=V)if(Q.dot(Y)<A){let es=Z+ee+ei;P[es][I[es]++]=L}break}default:L.aabbNeedsUpdate&&L.updateAABB(),q(L.aabb.lowerBound.x,L.aabb.lowerBound.y,L.aabb.lowerBound.z,L.aabb.upperBound.x,L.aabb.upperBound.y,L.aabb.upperBound.z,L)}}for(let eo=0;eo!==F;eo++){let en=I[eo];if(en>1){let er=P[eo];for(let ea=0;ea!==en;ea++){let el=er[ea];for(let eh=0;eh!==ea;eh++){let ec=er[eh];this.needBroadphaseCollision(el,ec)&&this.intersectionTest(el,ec,t,i)}}}}this.makePairsUnique(t,i)}}let GridBroadphase_collisionPairs_d=new Vec3;new Vec3;class NaiveBroadphase extends Broadphase{constructor(){super()}collisionPairs(e,t,i){let s=e.bodies,o=s.length,n,r;for(let l=0;l!==o;l++)for(let h=0;h!==l;h++)n=s[l],r=s[h],this.needBroadphaseCollision(n,r)&&this.intersectionTest(n,r,t,i)}aabbQuery(e,t,i){void 0===i&&(i=[]);for(let s=0;s<e.bodies.length;s++){let o=e.bodies[s];o.aabbNeedsUpdate&&o.updateAABB(),o.aabb.overlaps(t)&&i.push(o)}return i}}class RaycastResult{constructor(){this.rayFromWorld=new Vec3,this.rayToWorld=new Vec3,this.hitNormalWorld=new Vec3,this.hitPointWorld=new Vec3,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,i,s,o,n,r){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(i),this.hitPointWorld.copy(s),this.shape=o,this.body=n,this.distance=r}}let _Shape$types$SPHERE,_Shape$types$PLANE,_Shape$types$BOX,_Shape$types$CYLINDER,_Shape$types$CONVEXPO,_Shape$types$HEIGHTFI,_Shape$types$TRIMESH,RAY_MODES={CLOSEST:1,ANY:2,ALL:4};_Shape$types$SPHERE=Shape.types.SPHERE,_Shape$types$PLANE=Shape.types.PLANE,_Shape$types$BOX=Shape.types.BOX,_Shape$types$CYLINDER=Shape.types.CYLINDER,_Shape$types$CONVEXPO=Shape.types.CONVEXPOLYHEDRON,_Shape$types$HEIGHTFI=Shape.types.HEIGHTFIELD,_Shape$types$TRIMESH=Shape.types.TRIMESH;class Ray{get[_Shape$types$SPHERE](){return this._intersectSphere}get[_Shape$types$PLANE](){return this._intersectPlane}get[_Shape$types$BOX](){return this._intersectBox}get[_Shape$types$CYLINDER](){return this._intersectConvex}get[_Shape$types$CONVEXPO](){return this._intersectConvex}get[_Shape$types$HEIGHTFI](){return this._intersectHeightfield}get[_Shape$types$TRIMESH](){return this._intersectTrimesh}constructor(e,t){void 0===e&&(e=new Vec3),void 0===t&&(t=new Vec3),this.from=e.clone(),this.to=t.clone(),this.direction=new Vec3,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=Ray.ANY,this.result=new RaycastResult,this.hasHit=!1,this.callback=e=>{}}intersectWorld(e,t){return this.mode=t.mode||Ray.ANY,this.result=t.result||new RaycastResult,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===t.checkCollisionResponse||t.checkCollisionResponse,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(tmpAABB$1),tmpArray.length=0,e.broadphase.aabbQuery(e,tmpAABB$1,tmpArray),this.intersectBodies(tmpArray),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());let i=this.checkCollisionResponse;if(i&&!e.collisionResponse||(this.collisionFilterGroup&e.collisionFilterMask)==0||(e.collisionFilterGroup&this.collisionFilterMask)==0)return;let s=intersectBody_xi,o=intersectBody_qi;for(let n=0,r=e.shapes.length;n<r;n++){let l=e.shapes[n];if((!i||l.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[n],o),e.quaternion.vmult(e.shapeOffsets[n],s),s.vadd(e.position,s),this.intersectShape(l,o,s,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let i=0,s=e.length;!this.result.shouldStop&&i<s;i++)this.intersectBody(e[i])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,i,s){let o=this.from,n=distanceFromIntersection(o,this.direction,i);if(n>e.boundingSphereRadius)return;let r=this[e.type];r&&r.call(this,e,t,i,s,e)}_intersectBox(e,t,i,s,o){return this._intersectConvex(e.convexPolyhedronRepresentation,t,i,s,o)}_intersectPlane(e,t,i,s,o){let n=this.from,r=this.to,l=this.direction,h=new Vec3(0,0,1);t.vmult(h,h);let d=new Vec3;n.vsub(i,d);let p=d.dot(h);r.vsub(i,d);let u=d.dot(h);if(p*u>0||n.distanceTo(r)<p)return;let m=h.dot(l);if(Math.abs(m)<this.precision)return;let v=new Vec3,$=new Vec3,y=new Vec3;n.vsub(i,v);let g=-h.dot(v)/m;l.scale(g,$),n.vadd($,y),this.reportIntersection(h,y,o,s,-1)}getAABB(e){let{lowerBound:t,upperBound:i}=e,s=this.to,o=this.from;t.x=Math.min(s.x,o.x),t.y=Math.min(s.y,o.y),t.z=Math.min(s.z,o.z),i.x=Math.max(s.x,o.x),i.y=Math.max(s.y,o.y),i.z=Math.max(s.z,o.z)}_intersectHeightfield(e,t,i,s,o){e.data,e.elementSize;let n=intersectHeightfield_localRay;n.from.copy(this.from),n.to.copy(this.to),Transform.pointToLocalFrame(i,t,n.from,n.from),Transform.pointToLocalFrame(i,t,n.to,n.to),n.updateDirection();let r=intersectHeightfield_index,l,h,d,p;l=h=0,d=p=e.data.length-1;let u=new AABB;n.getAABB(u),e.getIndexOfPosition(u.lowerBound.x,u.lowerBound.y,r,!0),l=Math.max(l,r[0]),h=Math.max(h,r[1]),e.getIndexOfPosition(u.upperBound.x,u.upperBound.y,r,!0),d=Math.min(d,r[0]+1),p=Math.min(p,r[1]+1);for(let m=l;m<d;m++)for(let v=h;v<p;v++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(m,v,u),u.overlapsRay(n)){if(e.getConvexTrianglePillar(m,v,!1),Transform.pointToWorldFrame(i,t,e.pillarOffset,worldPillarOffset),this._intersectConvex(e.pillarConvex,t,worldPillarOffset,s,o,intersectConvexOptions),this.result.shouldStop)return;e.getConvexTrianglePillar(m,v,!0),Transform.pointToWorldFrame(i,t,e.pillarOffset,worldPillarOffset),this._intersectConvex(e.pillarConvex,t,worldPillarOffset,s,o,intersectConvexOptions)}}}_intersectSphere(e,t,i,s,o){let n=this.from,r=this.to,l=e.radius,h=(r.x-n.x)**2+(r.y-n.y)**2+(r.z-n.z)**2,d=2*((r.x-n.x)*(n.x-i.x)+(r.y-n.y)*(n.y-i.y)+(r.z-n.z)*(n.z-i.z)),p=(n.x-i.x)**2+(n.y-i.y)**2+(n.z-i.z)**2-l**2,u=d**2-4*h*p,m=Ray_intersectSphere_intersectionPoint,v=Ray_intersectSphere_normal;if(!(u<0)){if(0===u)n.lerp(r,u,m),m.vsub(i,v),v.normalize(),this.reportIntersection(v,m,o,s,-1);else{let $=(-d-Math.sqrt(u))/(2*h),y=(-d+Math.sqrt(u))/(2*h);if($>=0&&$<=1&&(n.lerp(r,$,m),m.vsub(i,v),v.normalize(),this.reportIntersection(v,m,o,s,-1)),this.result.shouldStop)return;y>=0&&y<=1&&(n.lerp(r,y,m),m.vsub(i,v),v.normalize(),this.reportIntersection(v,m,o,s,-1))}}}_intersectConvex(e,t,i,s,o,n){let r=intersectConvex_normal,l=intersectConvex_vector,h=n&&n.faceList||null,d=e.faces,p=e.vertices,u=e.faceNormals,m=this.direction,v=this.from,$=this.to,y=v.distanceTo($),g=h?h.length:d.length,x=this.result;for(let f=0;!x.shouldStop&&f<g;f++){let w=h?h[f]:f,B=d[w],_=u[w],S=t,V=i;l.copy(p[B[0]]),S.vmult(l,l),l.vadd(V,l),l.vsub(v,l),S.vmult(_,r);let A=m.dot(r);if(Math.abs(A)<this.precision)continue;let E=r.dot(l)/A;if(!(E<0)){m.scale(E,intersectPoint),intersectPoint.vadd(v,intersectPoint),a.copy(p[B[0]]),S.vmult(a,a),V.vadd(a,a);for(let C=1;!x.shouldStop&&C<B.length-1;C++){b.copy(p[B[C]]),c.copy(p[B[C+1]]),S.vmult(b,b),S.vmult(c,c),V.vadd(b,b),V.vadd(c,c);let T=intersectPoint.distanceTo(v);(Ray.pointInTriangle(intersectPoint,a,b,c)||Ray.pointInTriangle(intersectPoint,b,a,c))&&!(T>y)&&this.reportIntersection(r,intersectPoint,o,s,w)}}}}_intersectTrimesh(e,t,i,s,o,n){let r=intersectTrimesh_normal,l=intersectTrimesh_triangles,h=intersectTrimesh_treeTransform,d=intersectConvex_vector,p=intersectTrimesh_localDirection,u=intersectTrimesh_localFrom,m=intersectTrimesh_localTo,v=intersectTrimesh_worldIntersectPoint,$=intersectTrimesh_worldNormal,y=e.indices;e.vertices;let g=this.from,x=this.to,f=this.direction;h.position.copy(i),h.quaternion.copy(t),Transform.vectorToLocalFrame(i,t,f,p),Transform.pointToLocalFrame(i,t,g,u),Transform.pointToLocalFrame(i,t,x,m),m.x*=e.scale.x,m.y*=e.scale.y,m.z*=e.scale.z,u.x*=e.scale.x,u.y*=e.scale.y,u.z*=e.scale.z,m.vsub(u,p),p.normalize();let w=u.distanceSquared(m);e.tree.rayQuery(this,h,l);for(let B=0,_=l.length;!this.result.shouldStop&&B!==_;B++){let S=l[B];e.getNormal(S,r),e.getVertex(y[3*S],a),a.vsub(u,d);let V=p.dot(r),A=r.dot(d)/V;if(A<0)continue;p.scale(A,intersectPoint),intersectPoint.vadd(u,intersectPoint),e.getVertex(y[3*S+1],b),e.getVertex(y[3*S+2],c);let E=intersectPoint.distanceSquared(u);(Ray.pointInTriangle(intersectPoint,b,a,c)||Ray.pointInTriangle(intersectPoint,a,b,c))&&!(E>w)&&(Transform.vectorToWorldFrame(t,r,$),Transform.pointToWorldFrame(i,t,intersectPoint,v),this.reportIntersection($,v,o,s,S))}l.length=0}reportIntersection(e,t,i,s,o){let n=this.from,r=this.to,l=n.distanceTo(t),h=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(h.hitFaceIndex=void 0!==o?o:-1,this.mode){case Ray.ALL:this.hasHit=!0,h.set(n,r,e,t,i,s,l),h.hasHit=!0,this.callback(h);break;case Ray.CLOSEST:(l<h.distance||!h.hasHit)&&(this.hasHit=!0,h.hasHit=!0,h.set(n,r,e,t,i,s,l));break;case Ray.ANY:this.hasHit=!0,h.hasHit=!0,h.set(n,r,e,t,i,s,l),h.shouldStop=!0}}static pointInTriangle(e,t,i,s){s.vsub(t,v0),i.vsub(t,v1),e.vsub(t,v2);let o=v0.dot(v0),n=v0.dot(v1),r=v0.dot(v2),l=v1.dot(v1),h=v1.dot(v2),d,p;return(d=l*r-n*h)>=0&&(p=o*h-n*r)>=0&&d+p<o*l-n*n}}Ray.CLOSEST=RAY_MODES.CLOSEST,Ray.ANY=RAY_MODES.ANY,Ray.ALL=RAY_MODES.ALL;let tmpAABB$1=new AABB,tmpArray=[],v1=new Vec3,v2=new Vec3,intersectBody_xi=new Vec3,intersectBody_qi=new Quaternion,intersectPoint=new Vec3,a=new Vec3,b=new Vec3,c=new Vec3;new Vec3,new RaycastResult;let intersectConvexOptions={faceList:[0]},worldPillarOffset=new Vec3,intersectHeightfield_localRay=new Ray,intersectHeightfield_index=[],Ray_intersectSphere_intersectionPoint=new Vec3,Ray_intersectSphere_normal=new Vec3,intersectConvex_normal=new Vec3,intersectConvex_minDistNormal=new Vec3,intersectConvex_minDistIntersect=new Vec3,intersectConvex_vector=new Vec3,intersectTrimesh_normal=new Vec3,intersectTrimesh_localDirection=new Vec3,intersectTrimesh_localFrom=new Vec3,intersectTrimesh_localTo=new Vec3,intersectTrimesh_worldNormal=new Vec3,intersectTrimesh_worldIntersectPoint=new Vec3;new AABB;let intersectTrimesh_triangles=[],intersectTrimesh_treeTransform=new Transform,v0=new Vec3,intersect=new Vec3;function distanceFromIntersection(e,t,i){i.vsub(e,v0);let s=v0.dot(t);t.scale(s,intersect),intersect.vadd(e,intersect);let o=i.distanceTo(intersect);return o}class SAPBroadphase extends Broadphase{static checkBounds(e,t,i){let s,o;0===i?(s=e.position.x,o=t.position.x):1===i?(s=e.position.y,o=t.position.y):2===i&&(s=e.position.z,o=t.position.z);let n=e.boundingRadius,r=t.boundingRadius,l=s+n,h=o-r;return h<l}static insertionSortX(e){for(let t=1,i=e.length;t<i;t++){let s=e[t],o;for(o=t-1;o>=0&&!(e[o].aabb.lowerBound.x<=s.aabb.lowerBound.x);o--)e[o+1]=e[o];e[o+1]=s}return e}static insertionSortY(e){for(let t=1,i=e.length;t<i;t++){let s=e[t],o;for(o=t-1;o>=0&&!(e[o].aabb.lowerBound.y<=s.aabb.lowerBound.y);o--)e[o+1]=e[o];e[o+1]=s}return e}static insertionSortZ(e){for(let t=1,i=e.length;t<i;t++){let s=e[t],o;for(o=t-1;o>=0&&!(e[o].aabb.lowerBound.z<=s.aabb.lowerBound.z);o--)e[o+1]=e[o];e[o+1]=s}return e}constructor(e){super(),this.axisList=[],this.world=null,this.axisIndex=0;let t=this.axisList;this._addBodyHandler=e=>{t.push(e.body)},this._removeBodyHandler=e=>{let i=t.indexOf(e.body);-1!==i&&t.splice(i,1)},e&&this.setWorld(e)}setWorld(e){this.axisList.length=0;for(let t=0;t<e.bodies.length;t++)this.axisList.push(e.bodies[t]);e.removeEventListener("addBody",this._addBodyHandler),e.removeEventListener("removeBody",this._removeBodyHandler),e.addEventListener("addBody",this._addBodyHandler),e.addEventListener("removeBody",this._removeBodyHandler),this.world=e,this.dirty=!0}collisionPairs(e,t,i){let s=this.axisList,o=s.length,n=this.axisIndex,r,l;for(this.dirty&&(this.sortList(),this.dirty=!1),r=0;r!==o;r++){let h=s[r];for(l=r+1;l<o;l++){let d=s[l];if(this.needBroadphaseCollision(h,d)){if(!SAPBroadphase.checkBounds(h,d,n))break;this.intersectionTest(h,d,t,i)}}}}sortList(){let e=this.axisList,t=this.axisIndex,i=e.length;for(let s=0;s!==i;s++){let o=e[s];o.aabbNeedsUpdate&&o.updateAABB()}0===t?SAPBroadphase.insertionSortX(e):1===t?SAPBroadphase.insertionSortY(e):2===t&&SAPBroadphase.insertionSortZ(e)}autoDetectAxis(){let e=0,t=0,i=0,s=0,o=0,n=0,r=this.axisList,l=r.length,h=1/l;for(let d=0;d!==l;d++){let p=r[d],u=p.position.x;e+=u,t+=u*u;let m=p.position.y;i+=m,s+=m*m;let v=p.position.z;o+=v,n+=v*v}let $=t-e*e*h,y=s-i*i*h,g=n-o*o*h;$>y?$>g?this.axisIndex=0:this.axisIndex=2:y>g?this.axisIndex=1:this.axisIndex=2}aabbQuery(e,t,i){void 0===i&&(i=[]),this.dirty&&(this.sortList(),this.dirty=!1);let s=this.axisIndex,o="x";1===s&&(o="y"),2===s&&(o="z");let n=this.axisList;t.lowerBound[o],t.upperBound[o];for(let r=0;r<n.length;r++){let l=n[r];l.aabbNeedsUpdate&&l.updateAABB(),l.aabb.overlaps(t)&&i.push(l)}return i}}class Utils{static defaults(e,t){for(let i in void 0===e&&(e={}),t)i in e||(e[i]=t[i]);return e}}class Constraint{constructor(e,t,i){void 0===i&&(i={}),i=Utils.defaults(i,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=t,this.id=Constraint.idCounter++,this.collideConnected=i.collideConnected,i.wakeUpBodies&&(e&&e.wakeUp(),t&&t.wakeUp())}update(){throw Error("method update() not implmemented in this Constraint subclass!")}enable(){let e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!0}disable(){let e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!1}}Constraint.idCounter=0;class JacobianElement{constructor(){this.spatial=new Vec3,this.rotational=new Vec3}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class Equation{constructor(e,t,i,s){void 0===i&&(i=-1e6),void 0===s&&(s=1e6),this.id=Equation.idCounter++,this.minForce=i,this.maxForce=s,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new JacobianElement,this.jacobianElementB=new JacobianElement,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,i){let s=t,o=i;this.a=4/(o*(1+4*s)),this.b=4*s/(1+4*s),this.eps=4/(o*o*e*(1+4*s))}computeB(e,t,i){let s=this.computeGW(),o=this.computeGq(),n=this.computeGiMf();return-o*e-s*t-n*i}computeGq(){let e=this.jacobianElementA,t=this.jacobianElementB,i=this.bi,s=this.bj,o=i.position,n=s.position;return e.spatial.dot(o)+t.spatial.dot(n)}computeGW(){let e=this.jacobianElementA,t=this.jacobianElementB,i=this.bi,s=this.bj,o=i.velocity,n=s.velocity,r=i.angularVelocity,l=s.angularVelocity;return e.multiplyVectors(o,r)+t.multiplyVectors(n,l)}computeGWlambda(){let e=this.jacobianElementA,t=this.jacobianElementB,i=this.bi,s=this.bj,o=i.vlambda,n=s.vlambda,r=i.wlambda,l=s.wlambda;return e.multiplyVectors(o,r)+t.multiplyVectors(n,l)}computeGiMf(){let e=this.jacobianElementA,t=this.jacobianElementB,i=this.bi,s=this.bj,o=i.force,n=i.torque,r=s.force,l=s.torque,h=i.invMassSolve,d=s.invMassSolve;return o.scale(h,iMfi),r.scale(d,iMfj),i.invInertiaWorldSolve.vmult(n,invIi_vmult_taui),s.invInertiaWorldSolve.vmult(l,invIj_vmult_tauj),e.multiplyVectors(iMfi,invIi_vmult_taui)+t.multiplyVectors(iMfj,invIj_vmult_tauj)}computeGiMGt(){let e=this.jacobianElementA,t=this.jacobianElementB,i=this.bi,s=this.bj,o=i.invMassSolve,n=s.invMassSolve,r=i.invInertiaWorldSolve,l=s.invInertiaWorldSolve,h=o+n;return r.vmult(e.rotational,tmp),h+=tmp.dot(e.rotational),l.vmult(t.rotational,tmp),h+=tmp.dot(t.rotational)}addToWlambda(e){let t=this.jacobianElementA,i=this.jacobianElementB,s=this.bi,o=this.bj,n=addToWlambda_temp;s.vlambda.addScaledVector(s.invMassSolve*e,t.spatial,s.vlambda),o.vlambda.addScaledVector(o.invMassSolve*e,i.spatial,o.vlambda),s.invInertiaWorldSolve.vmult(t.rotational,n),s.wlambda.addScaledVector(e,n,s.wlambda),o.invInertiaWorldSolve.vmult(i.rotational,n),o.wlambda.addScaledVector(e,n,o.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}Equation.idCounter=0;let iMfi=new Vec3,iMfj=new Vec3,invIi_vmult_taui=new Vec3,invIj_vmult_tauj=new Vec3,tmp=new Vec3,addToWlambda_temp=new Vec3;class ContactEquation extends Equation{constructor(e,t,i){void 0===i&&(i=1e6),super(e,t,0,i),this.restitution=0,this.ri=new Vec3,this.rj=new Vec3,this.ni=new Vec3}computeB(e){let t=this.a,i=this.b,s=this.bi,o=this.bj,n=this.ri,r=this.rj,l=ContactEquation_computeB_temp1,h=ContactEquation_computeB_temp2,d=s.velocity,p=s.angularVelocity;s.force,s.torque;let u=o.velocity,m=o.angularVelocity;o.force,o.torque;let v=ContactEquation_computeB_temp3,$=this.jacobianElementA,y=this.jacobianElementB,g=this.ni;n.cross(g,l),r.cross(g,h),g.negate($.spatial),l.negate($.rotational),y.spatial.copy(g),y.rotational.copy(h),v.copy(o.position),v.vadd(r,v),v.vsub(s.position,v),v.vsub(n,v);let x=g.dot(v),f=this.restitution+1,w=f*u.dot(g)-f*d.dot(g)+m.dot(h)-p.dot(l),B=this.computeGiMf();return-x*t-w*i-e*B}getImpactVelocityAlongNormal(){let e=ContactEquation_getImpactVelocityAlongNormal_vi,t=ContactEquation_getImpactVelocityAlongNormal_vj,i=ContactEquation_getImpactVelocityAlongNormal_xi,s=ContactEquation_getImpactVelocityAlongNormal_xj,o=ContactEquation_getImpactVelocityAlongNormal_relVel;return this.bi.position.vadd(this.ri,i),this.bj.position.vadd(this.rj,s),this.bi.getVelocityAtWorldPoint(i,e),this.bj.getVelocityAtWorldPoint(s,t),e.vsub(t,o),this.ni.dot(o)}}let ContactEquation_computeB_temp1=new Vec3,ContactEquation_computeB_temp2=new Vec3,ContactEquation_computeB_temp3=new Vec3,ContactEquation_getImpactVelocityAlongNormal_vi=new Vec3,ContactEquation_getImpactVelocityAlongNormal_vj=new Vec3,ContactEquation_getImpactVelocityAlongNormal_xi=new Vec3,ContactEquation_getImpactVelocityAlongNormal_xj=new Vec3,ContactEquation_getImpactVelocityAlongNormal_relVel=new Vec3;class PointToPointConstraint extends Constraint{constructor(e,t,i,s,o){void 0===t&&(t=new Vec3),void 0===s&&(s=new Vec3),void 0===o&&(o=1e6),super(e,i),this.pivotA=t.clone(),this.pivotB=s.clone();let n=this.equationX=new ContactEquation(e,i),r=this.equationY=new ContactEquation(e,i),l=this.equationZ=new ContactEquation(e,i);this.equations.push(n,r,l),n.minForce=r.minForce=l.minForce=-o,n.maxForce=r.maxForce=l.maxForce=o,n.ni.set(1,0,0),r.ni.set(0,1,0),l.ni.set(0,0,1)}update(){let e=this.bodyA,t=this.bodyB,i=this.equationX,s=this.equationY,o=this.equationZ;e.quaternion.vmult(this.pivotA,i.ri),t.quaternion.vmult(this.pivotB,i.rj),s.ri.copy(i.ri),s.rj.copy(i.rj),o.ri.copy(i.ri),o.rj.copy(i.rj)}}class ConeEquation extends Equation{constructor(e,t,i){void 0===i&&(i={});let s=void 0!==i.maxForce?i.maxForce:1e6;super(e,t,-s,s),this.axisA=i.axisA?i.axisA.clone():new Vec3(1,0,0),this.axisB=i.axisB?i.axisB.clone():new Vec3(0,1,0),this.angle=void 0!==i.angle?i.angle:0}computeB(e){let t=this.a,i=this.b,s=this.axisA,o=this.axisB,n=tmpVec1$2,r=tmpVec2$2,l=this.jacobianElementA,h=this.jacobianElementB;s.cross(o,n),o.cross(s,r),l.rotational.copy(r),h.rotational.copy(n);let d=Math.cos(this.angle)-s.dot(o),p=this.computeGW(),u=this.computeGiMf();return-d*t-p*i-e*u}}let tmpVec1$2=new Vec3,tmpVec2$2=new Vec3;class RotationalEquation extends Equation{constructor(e,t,i){void 0===i&&(i={});let s=void 0!==i.maxForce?i.maxForce:1e6;super(e,t,-s,s),this.axisA=i.axisA?i.axisA.clone():new Vec3(1,0,0),this.axisB=i.axisB?i.axisB.clone():new Vec3(0,1,0),this.maxAngle=Math.PI/2}computeB(e){let t=this.a,i=this.b,s=this.axisA,o=this.axisB,n=tmpVec1$1,r=tmpVec2$1,l=this.jacobianElementA,h=this.jacobianElementB;s.cross(o,n),o.cross(s,r),l.rotational.copy(r),h.rotational.copy(n);let d=Math.cos(this.maxAngle)-s.dot(o),p=this.computeGW(),u=this.computeGiMf();return-d*t-p*i-e*u}}let tmpVec1$1=new Vec3,tmpVec2$1=new Vec3;class ConeTwistConstraint extends PointToPointConstraint{constructor(e,t,i){void 0===i&&(i={});let s=void 0!==i.maxForce?i.maxForce:1e6,o=i.pivotA?i.pivotA.clone():new Vec3,n=i.pivotB?i.pivotB.clone():new Vec3;super(e,o,t,n,s),this.axisA=i.axisA?i.axisA.clone():new Vec3,this.axisB=i.axisB?i.axisB.clone():new Vec3,this.collideConnected=!!i.collideConnected,this.angle=void 0!==i.angle?i.angle:0;let r=this.coneEquation=new ConeEquation(e,t,i),l=this.twistEquation=new RotationalEquation(e,t,i);this.twistAngle=void 0!==i.twistAngle?i.twistAngle:0,r.maxForce=0,r.minForce=-s,l.maxForce=0,l.minForce=-s,this.equations.push(r,l)}update(){let e=this.bodyA,t=this.bodyB,i=this.coneEquation,s=this.twistEquation;super.update(),e.vectorToWorldFrame(this.axisA,i.axisA),t.vectorToWorldFrame(this.axisB,i.axisB),this.axisA.tangents(s.axisA,s.axisA),e.vectorToWorldFrame(s.axisA,s.axisA),this.axisB.tangents(s.axisB,s.axisB),t.vectorToWorldFrame(s.axisB,s.axisB),i.angle=this.angle,s.maxAngle=this.twistAngle}}new Vec3,new Vec3;class DistanceConstraint extends Constraint{constructor(e,t,i,s){void 0===s&&(s=1e6),super(e,t),void 0===i&&(i=e.position.distanceTo(t.position)),this.distance=i;let o=this.distanceEquation=new ContactEquation(e,t);this.equations.push(o),o.minForce=-s,o.maxForce=s}update(){let e=this.bodyA,t=this.bodyB,i=this.distanceEquation,s=.5*this.distance,o=i.ni;t.position.vsub(e.position,o),o.normalize(),o.scale(s,i.ri),o.scale(-s,i.rj)}}class LockConstraint extends PointToPointConstraint{constructor(e,t,i){void 0===i&&(i={});let s=void 0!==i.maxForce?i.maxForce:1e6,o=new Vec3,n=new Vec3,r=new Vec3;e.position.vadd(t.position,r),r.scale(.5,r),t.pointToLocalFrame(r,n),e.pointToLocalFrame(r,o),super(e,o,t,n,s),this.xA=e.vectorToLocalFrame(Vec3.UNIT_X),this.xB=t.vectorToLocalFrame(Vec3.UNIT_X),this.yA=e.vectorToLocalFrame(Vec3.UNIT_Y),this.yB=t.vectorToLocalFrame(Vec3.UNIT_Y),this.zA=e.vectorToLocalFrame(Vec3.UNIT_Z),this.zB=t.vectorToLocalFrame(Vec3.UNIT_Z);let l=this.rotationalEquation1=new RotationalEquation(e,t,i),h=this.rotationalEquation2=new RotationalEquation(e,t,i),d=this.rotationalEquation3=new RotationalEquation(e,t,i);this.equations.push(l,h,d)}update(){let e=this.bodyA,t=this.bodyB;this.motorEquation;let i=this.rotationalEquation1,s=this.rotationalEquation2,o=this.rotationalEquation3;super.update(),e.vectorToWorldFrame(this.xA,i.axisA),t.vectorToWorldFrame(this.yB,i.axisB),e.vectorToWorldFrame(this.yA,s.axisA),t.vectorToWorldFrame(this.zB,s.axisB),e.vectorToWorldFrame(this.zA,o.axisA),t.vectorToWorldFrame(this.xB,o.axisB)}}let LockConstraint_update_tmpVec1=new Vec3,LockConstraint_update_tmpVec2=new Vec3;class RotationalMotorEquation extends Equation{constructor(e,t,i){void 0===i&&(i=1e6),super(e,t,-i,i),this.axisA=new Vec3,this.axisB=new Vec3,this.targetVelocity=0}computeB(e){this.a;let t=this.b;this.bi,this.bj;let i=this.axisA,s=this.axisB,o=this.jacobianElementA,n=this.jacobianElementB;o.rotational.copy(i),s.negate(n.rotational);let r=this.computeGW()-this.targetVelocity,l=this.computeGiMf();return-r*t-e*l}}class HingeConstraint extends PointToPointConstraint{constructor(e,t,i){void 0===i&&(i={});let s=void 0!==i.maxForce?i.maxForce:1e6,o=i.pivotA?i.pivotA.clone():new Vec3,n=i.pivotB?i.pivotB.clone():new Vec3;super(e,o,t,n,s);let r=this.axisA=i.axisA?i.axisA.clone():new Vec3(1,0,0);r.normalize();let l=this.axisB=i.axisB?i.axisB.clone():new Vec3(1,0,0);l.normalize(),this.collideConnected=!!i.collideConnected;let h=this.rotationalEquation1=new RotationalEquation(e,t,i),d=this.rotationalEquation2=new RotationalEquation(e,t,i),p=this.motorEquation=new RotationalMotorEquation(e,t,s);p.enabled=!1,this.equations.push(h,d,p)}enableMotor(){this.motorEquation.enabled=!0}disableMotor(){this.motorEquation.enabled=!1}setMotorSpeed(e){this.motorEquation.targetVelocity=e}setMotorMaxForce(e){this.motorEquation.maxForce=e,this.motorEquation.minForce=-e}update(){let e=this.bodyA,t=this.bodyB,i=this.motorEquation,s=this.rotationalEquation1,o=this.rotationalEquation2,n=HingeConstraint_update_tmpVec1,r=HingeConstraint_update_tmpVec2,l=this.axisA,h=this.axisB;super.update(),e.quaternion.vmult(l,n),t.quaternion.vmult(h,r),n.tangents(s.axisA,o.axisA),s.axisB.copy(r),o.axisB.copy(r),this.motorEquation.enabled&&(e.quaternion.vmult(this.axisA,i.axisA),t.quaternion.vmult(this.axisB,i.axisB))}}let HingeConstraint_update_tmpVec1=new Vec3,HingeConstraint_update_tmpVec2=new Vec3;class FrictionEquation extends Equation{constructor(e,t,i){super(e,t,-i,i),this.ri=new Vec3,this.rj=new Vec3,this.t=new Vec3}computeB(e){this.a;let t=this.b;this.bi,this.bj;let i=this.ri,s=this.rj,o=FrictionEquation_computeB_temp1,n=FrictionEquation_computeB_temp2,r=this.t;i.cross(r,o),s.cross(r,n);let l=this.jacobianElementA,h=this.jacobianElementB;r.negate(l.spatial),o.negate(l.rotational),h.spatial.copy(r),h.rotational.copy(n);let d=this.computeGW(),p=this.computeGiMf();return-d*t-e*p}}let FrictionEquation_computeB_temp1=new Vec3,FrictionEquation_computeB_temp2=new Vec3;class ContactMaterial{constructor(e,t,i){i=Utils.defaults(i,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=ContactMaterial.idCounter++,this.materials=[e,t],this.friction=i.friction,this.restitution=i.restitution,this.contactEquationStiffness=i.contactEquationStiffness,this.contactEquationRelaxation=i.contactEquationRelaxation,this.frictionEquationStiffness=i.frictionEquationStiffness,this.frictionEquationRelaxation=i.frictionEquationRelaxation}}ContactMaterial.idCounter=0;class Material{constructor(e){void 0===e&&(e={});let t="";"string"==typeof e&&(t=e,e={}),this.name=t,this.id=Material.idCounter++,this.friction=void 0!==e.friction?e.friction:-1,this.restitution=void 0!==e.restitution?e.restitution:-1}}Material.idCounter=0;class Spring{constructor(e,t,i){void 0===i&&(i={}),this.restLength="number"==typeof i.restLength?i.restLength:1,this.stiffness=i.stiffness||100,this.damping=i.damping||1,this.bodyA=e,this.bodyB=t,this.localAnchorA=new Vec3,this.localAnchorB=new Vec3,i.localAnchorA&&this.localAnchorA.copy(i.localAnchorA),i.localAnchorB&&this.localAnchorB.copy(i.localAnchorB),i.worldAnchorA&&this.setWorldAnchorA(i.worldAnchorA),i.worldAnchorB&&this.setWorldAnchorB(i.worldAnchorB)}setWorldAnchorA(e){this.bodyA.pointToLocalFrame(e,this.localAnchorA)}setWorldAnchorB(e){this.bodyB.pointToLocalFrame(e,this.localAnchorB)}getWorldAnchorA(e){this.bodyA.pointToWorldFrame(this.localAnchorA,e)}getWorldAnchorB(e){this.bodyB.pointToWorldFrame(this.localAnchorB,e)}applyForce(){let e=this.stiffness,t=this.damping,i=this.restLength,s=this.bodyA,o=this.bodyB,n=applyForce_r,r=applyForce_r_unit,l=applyForce_u,h=applyForce_f,d=applyForce_tmp,p=applyForce_worldAnchorA,u=applyForce_worldAnchorB,m=applyForce_ri,v=applyForce_rj,$=applyForce_ri_x_f,y=applyForce_rj_x_f;this.getWorldAnchorA(p),this.getWorldAnchorB(u),p.vsub(s.position,m),u.vsub(o.position,v),u.vsub(p,n);let g=n.length();r.copy(n),r.normalize(),o.velocity.vsub(s.velocity,l),o.angularVelocity.cross(v,d),l.vadd(d,l),s.angularVelocity.cross(m,d),l.vsub(d,l),r.scale(-e*(g-i)-t*l.dot(r),h),s.force.vsub(h,s.force),o.force.vadd(h,o.force),m.cross(h,$),v.cross(h,y),s.torque.vsub($,s.torque),o.torque.vadd(y,o.torque)}}let applyForce_r=new Vec3,applyForce_r_unit=new Vec3,applyForce_u=new Vec3,applyForce_f=new Vec3,applyForce_worldAnchorA=new Vec3,applyForce_worldAnchorB=new Vec3,applyForce_ri=new Vec3,applyForce_rj=new Vec3,applyForce_ri_x_f=new Vec3,applyForce_rj_x_f=new Vec3,applyForce_tmp=new Vec3;class WheelInfo{constructor(e){void 0===e&&(e={}),e=Utils.defaults(e,{chassisConnectionPointLocal:new Vec3,chassisConnectionPointWorld:new Vec3,directionLocal:new Vec3,directionWorld:new Vec3,axleLocal:new Vec3,axleWorld:new Vec3,suspensionRestLength:1,suspensionMaxLength:2,radius:1,suspensionStiffness:100,dampingCompression:10,dampingRelaxation:10,frictionSlip:10.5,forwardAcceleration:1,sideAcceleration:1,steering:0,rotation:0,deltaRotation:0,rollInfluence:.01,maxSuspensionForce:Number.MAX_VALUE,isFrontWheel:!0,clippedInvContactDotSuspension:1,suspensionRelativeVelocity:0,suspensionForce:0,slipInfo:0,skidInfo:0,suspensionLength:0,maxSuspensionTravel:1,useCustomSlidingRotationalSpeed:!1,customSlidingRotationalSpeed:-.1}),this.maxSuspensionTravel=e.maxSuspensionTravel,this.customSlidingRotationalSpeed=e.customSlidingRotationalSpeed,this.useCustomSlidingRotationalSpeed=e.useCustomSlidingRotationalSpeed,this.sliding=!1,this.chassisConnectionPointLocal=e.chassisConnectionPointLocal.clone(),this.chassisConnectionPointWorld=e.chassisConnectionPointWorld.clone(),this.directionLocal=e.directionLocal.clone(),this.directionWorld=e.directionWorld.clone(),this.axleLocal=e.axleLocal.clone(),this.axleWorld=e.axleWorld.clone(),this.suspensionRestLength=e.suspensionRestLength,this.suspensionMaxLength=e.suspensionMaxLength,this.radius=e.radius,this.suspensionStiffness=e.suspensionStiffness,this.dampingCompression=e.dampingCompression,this.dampingRelaxation=e.dampingRelaxation,this.frictionSlip=e.frictionSlip,this.forwardAcceleration=e.forwardAcceleration,this.sideAcceleration=e.sideAcceleration,this.steering=0,this.rotation=0,this.deltaRotation=0,this.rollInfluence=e.rollInfluence,this.maxSuspensionForce=e.maxSuspensionForce,this.engineForce=0,this.brake=0,this.isFrontWheel=e.isFrontWheel,this.clippedInvContactDotSuspension=1,this.suspensionRelativeVelocity=0,this.suspensionForce=0,this.slipInfo=0,this.skidInfo=0,this.suspensionLength=0,this.sideImpulse=0,this.forwardImpulse=0,this.raycastResult=new RaycastResult,this.worldTransform=new Transform,this.isInContact=!1}updateWheel(e){let t=this.raycastResult;if(this.isInContact){let i=t.hitNormalWorld.dot(t.directionWorld);t.hitPointWorld.vsub(e.position,relpos),e.getVelocityAtWorldPoint(relpos,chassis_velocity_at_contactPoint);let s=t.hitNormalWorld.dot(chassis_velocity_at_contactPoint);if(i>=-.1)this.suspensionRelativeVelocity=0,this.clippedInvContactDotSuspension=10;else{let o=-1/i;this.suspensionRelativeVelocity=s*o,this.clippedInvContactDotSuspension=o}}else t.suspensionLength=this.suspensionRestLength,this.suspensionRelativeVelocity=0,t.directionWorld.scale(-1,t.hitNormalWorld),this.clippedInvContactDotSuspension=1}}let chassis_velocity_at_contactPoint=new Vec3,relpos=new Vec3;class RaycastVehicle{constructor(e){this.chassisBody=e.chassisBody,this.wheelInfos=[],this.sliding=!1,this.world=null,this.indexRightAxis=void 0!==e.indexRightAxis?e.indexRightAxis:2,this.indexForwardAxis=void 0!==e.indexForwardAxis?e.indexForwardAxis:0,this.indexUpAxis=void 0!==e.indexUpAxis?e.indexUpAxis:1,this.constraints=[],this.preStepCallback=()=>{},this.currentVehicleSpeedKmHour=0,this.numWheelsOnGround=0}addWheel(e){void 0===e&&(e={});let t=new WheelInfo(e),i=this.wheelInfos.length;return this.wheelInfos.push(t),i}setSteeringValue(e,t){let i=this.wheelInfos[t];i.steering=e}applyEngineForce(e,t){this.wheelInfos[t].engineForce=e}setBrake(e,t){this.wheelInfos[t].brake=e}addToWorld(e){e.addBody(this.chassisBody);let t=this;this.preStepCallback=()=>{t.updateVehicle(e.dt)},e.addEventListener("preStep",this.preStepCallback),this.world=e}getVehicleAxisWorld(e,t){t.set(0===e?1:0,1===e?1:0,2===e?1:0),this.chassisBody.vectorToWorldFrame(t,t)}updateVehicle(e){let t=this.wheelInfos,i=t.length,s=this.chassisBody;for(let o=0;o<i;o++)this.updateWheelTransform(o);this.currentVehicleSpeedKmHour=3.6*s.velocity.length();let n=new Vec3;this.getVehicleAxisWorld(this.indexForwardAxis,n),0>n.dot(s.velocity)&&(this.currentVehicleSpeedKmHour*=-1);for(let r=0;r<i;r++)this.castRay(t[r]);this.updateSuspension(e);let l=new Vec3,h=new Vec3;for(let d=0;d<i;d++){let p=t[d],u=p.suspensionForce;u>p.maxSuspensionForce&&(u=p.maxSuspensionForce),p.raycastResult.hitNormalWorld.scale(u*e,l),p.raycastResult.hitPointWorld.vsub(s.position,h),s.applyImpulse(l,h)}this.updateFriction(e);let m=new Vec3,v=new Vec3,$=new Vec3;for(let y=0;y<i;y++){let g=t[y];s.getVelocityAtWorldPoint(g.chassisConnectionPointWorld,$);let x=1;if(1===this.indexUpAxis&&(x=-1),g.isInContact){this.getVehicleAxisWorld(this.indexForwardAxis,v);let f=v.dot(g.raycastResult.hitNormalWorld);g.raycastResult.hitNormalWorld.scale(f,m),v.vsub(m,v);let w=v.dot($);g.deltaRotation=x*w*e/g.radius}(g.sliding||!g.isInContact)&&0!==g.engineForce&&g.useCustomSlidingRotationalSpeed&&(g.deltaRotation=(g.engineForce>0?1:-1)*g.customSlidingRotationalSpeed*e),Math.abs(g.brake)>Math.abs(g.engineForce)&&(g.deltaRotation=0),g.rotation+=g.deltaRotation,g.deltaRotation*=.99}}updateSuspension(e){let t=this.chassisBody,i=t.mass,s=this.wheelInfos,o=s.length;for(let n=0;n<o;n++){let r=s[n];if(r.isInContact){let l,h=r.suspensionRestLength,d=r.suspensionLength,p=h-d;l=r.suspensionStiffness*p*r.clippedInvContactDotSuspension;let u=r.suspensionRelativeVelocity,m;l-=(m=u<0?r.dampingCompression:r.dampingRelaxation)*u,r.suspensionForce=l*i,r.suspensionForce<0&&(r.suspensionForce=0)}else r.suspensionForce=0}}removeFromWorld(e){this.constraints,e.removeBody(this.chassisBody),e.removeEventListener("preStep",this.preStepCallback),this.world=null}castRay(e){let t=castRay_rayvector,i=castRay_target;this.updateWheelTransformWorld(e);let s=this.chassisBody,o=-1,n=e.suspensionRestLength+e.radius;e.directionWorld.scale(n,t);let r=e.chassisConnectionPointWorld;r.vadd(t,i);let l=e.raycastResult;l.reset();let h=s.collisionResponse;s.collisionResponse=!1,this.world.rayTest(r,i,l),s.collisionResponse=h;let d=l.body;if(e.raycastResult.groundObject=0,d){o=l.distance,e.raycastResult.hitNormalWorld=l.hitNormalWorld,e.isInContact=!0;let p=l.distance;e.suspensionLength=p-e.radius;let u=e.suspensionRestLength-e.maxSuspensionTravel,m=e.suspensionRestLength+e.maxSuspensionTravel;e.suspensionLength<u&&(e.suspensionLength=u),e.suspensionLength>m&&(e.suspensionLength=m,e.raycastResult.reset());let v=e.raycastResult.hitNormalWorld.dot(e.directionWorld),$=new Vec3;s.getVelocityAtWorldPoint(e.raycastResult.hitPointWorld,$);let y=e.raycastResult.hitNormalWorld.dot($);if(v>=-.1)e.suspensionRelativeVelocity=0,e.clippedInvContactDotSuspension=10;else{let g=-1/v;e.suspensionRelativeVelocity=y*g,e.clippedInvContactDotSuspension=g}}else e.suspensionLength=e.suspensionRestLength+0*e.maxSuspensionTravel,e.suspensionRelativeVelocity=0,e.directionWorld.scale(-1,e.raycastResult.hitNormalWorld),e.clippedInvContactDotSuspension=1;return o}updateWheelTransformWorld(e){e.isInContact=!1;let t=this.chassisBody;t.pointToWorldFrame(e.chassisConnectionPointLocal,e.chassisConnectionPointWorld),t.vectorToWorldFrame(e.directionLocal,e.directionWorld),t.vectorToWorldFrame(e.axleLocal,e.axleWorld)}updateWheelTransform(e){let t=tmpVec4,i=tmpVec5,s=tmpVec6,o=this.wheelInfos[e];this.updateWheelTransformWorld(o),o.directionLocal.scale(-1,t),i.copy(o.axleLocal),t.cross(i,s),s.normalize(),i.normalize();let n=o.steering,r=new Quaternion;r.setFromAxisAngle(t,n);let l=new Quaternion;l.setFromAxisAngle(i,o.rotation);let h=o.worldTransform.quaternion;this.chassisBody.quaternion.mult(r,h),h.mult(l,h),h.normalize();let d=o.worldTransform.position;d.copy(o.directionWorld),d.scale(o.suspensionLength,d),d.vadd(o.chassisConnectionPointWorld,d)}getWheelTransformWorld(e){return this.wheelInfos[e].worldTransform}updateFriction(e){let t=updateFriction_surfNormalWS_scaled_proj,i=this.wheelInfos,s=i.length,o=this.chassisBody,n=updateFriction_forwardWS,r=updateFriction_axle;this.numWheelsOnGround=0;for(let l=0;l<s;l++){let h=i[l],d=h.raycastResult.body;d&&this.numWheelsOnGround++,h.sideImpulse=0,h.forwardImpulse=0,n[l]||(n[l]=new Vec3),r[l]||(r[l]=new Vec3)}for(let p=0;p<s;p++){let u=i[p],m=u.raycastResult.body;if(m){let v=r[p],$=this.getWheelTransformWorld(p);$.vectorToWorldFrame(directions[this.indexRightAxis],v);let y=u.raycastResult.hitNormalWorld,g=v.dot(y);y.scale(g,t),v.vsub(t,v),v.normalize(),y.cross(v,n[p]),n[p].normalize(),u.sideImpulse=resolveSingleBilateral(o,u.raycastResult.hitPointWorld,m,u.raycastResult.hitPointWorld,v),u.sideImpulse*=sideFrictionStiffness2}}this.sliding=!1;for(let x=0;x<s;x++){let f=i[x],w=f.raycastResult.body,B=0;if(f.slipInfo=1,w){let _=f.brake?f.brake:0;B=calcRollingFriction(o,w,f.raycastResult.hitPointWorld,n[x],_),B+=f.engineForce*e;let S=_/B;f.slipInfo*=S}if(f.forwardImpulse=0,f.skidInfo=1,w){f.skidInfo=1;let V=f.suspensionForce*e*f.frictionSlip,A=V,E=V*A;f.forwardImpulse=B;let C=.5*f.forwardImpulse/f.forwardAcceleration,T=1*f.sideImpulse/f.sideAcceleration,P=C*C+T*T;if(f.sliding=!1,P>E){this.sliding=!0,f.sliding=!0;let I=V/Math.sqrt(P);f.skidInfo*=I}}}if(this.sliding)for(let F=0;F<s;F++){let R=i[F];0!==R.sideImpulse&&R.skidInfo<1&&(R.forwardImpulse*=R.skidInfo,R.sideImpulse*=R.skidInfo)}for(let z=0;z<s;z++){let q=i[z],N=new Vec3;if(q.raycastResult.hitPointWorld.vsub(o.position,N),0!==q.forwardImpulse){let L=new Vec3;n[z].scale(q.forwardImpulse,L),o.applyImpulse(L,N)}if(0!==q.sideImpulse){let W=q.raycastResult.body,O=new Vec3;q.raycastResult.hitPointWorld.vsub(W.position,O);let M=new Vec3;r[z].scale(q.sideImpulse,M),o.vectorToLocalFrame(N,N),N["xyz"[this.indexUpAxis]]*=q.rollInfluence,o.vectorToWorldFrame(N,N),o.applyImpulse(M,N),M.scale(-1,M),W.applyImpulse(M,O)}}}}new Vec3,new Vec3,new Vec3;let tmpVec4=new Vec3,tmpVec5=new Vec3,tmpVec6=new Vec3;new Ray,new Vec3;let castRay_rayvector=new Vec3,castRay_target=new Vec3,directions=[new Vec3(1,0,0),new Vec3(0,1,0),new Vec3(0,0,1)],updateFriction_surfNormalWS_scaled_proj=new Vec3,updateFriction_axle=[],updateFriction_forwardWS=[],sideFrictionStiffness2=1,calcRollingFriction_vel1=new Vec3,calcRollingFriction_vel2=new Vec3,calcRollingFriction_vel=new Vec3;function calcRollingFriction(e,t,i,s,o){let n=0,r=i,l=calcRollingFriction_vel1,h=calcRollingFriction_vel2,d=calcRollingFriction_vel;e.getVelocityAtWorldPoint(r,l),t.getVelocityAtWorldPoint(r,h),l.vsub(h,d);let p=s.dot(d),u=computeImpulseDenominator(e,i,s),m=computeImpulseDenominator(t,i,s);return o<(n=-p*(1/(u+m)))&&(n=o),n<-o&&(n=-o),n}let computeImpulseDenominator_r0=new Vec3,computeImpulseDenominator_c0=new Vec3,computeImpulseDenominator_vec=new Vec3,computeImpulseDenominator_m=new Vec3;function computeImpulseDenominator(e,t,i){let s=computeImpulseDenominator_r0,o=computeImpulseDenominator_c0,n=computeImpulseDenominator_vec,r=computeImpulseDenominator_m;return t.vsub(e.position,s),s.cross(i,o),e.invInertiaWorld.vmult(o,r),r.cross(s,n),e.invMass+i.dot(n)}let resolveSingleBilateral_vel1=new Vec3,resolveSingleBilateral_vel2=new Vec3,resolveSingleBilateral_vel=new Vec3;function resolveSingleBilateral(e,t,i,s,o){let n=o.lengthSquared();if(n>1.1)return 0;let r=resolveSingleBilateral_vel1,l=resolveSingleBilateral_vel2,h=resolveSingleBilateral_vel;e.getVelocityAtWorldPoint(t,r),i.getVelocityAtWorldPoint(s,l),r.vsub(l,h);let d=o.dot(h),p=1/(e.invMass+i.invMass);return -.2*d*p}class Sphere extends Shape{constructor(e){if(super({type:Shape.types.SPHERE}),this.radius=void 0!==e?e:1,this.radius<0)throw Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(e,t){void 0===t&&(t=new Vec3);let i=2*e*this.radius*this.radius/5;return t.x=i,t.y=i,t.z=i,t}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(e,t,i,s){let o=this.radius,n=["x","y","z"];for(let r=0;r<n.length;r++){let l=n[r];i[l]=e[l]-o,s[l]=e[l]+o}}}class RigidVehicle{constructor(e){void 0===e&&(e={}),this.wheelBodies=[],this.coordinateSystem=void 0!==e.coordinateSystem?e.coordinateSystem.clone():new Vec3(1,2,3),e.chassisBody?this.chassisBody=e.chassisBody:this.chassisBody=new Body({mass:1,shape:new Box(new Vec3(5,.5,2))}),this.constraints=[],this.wheelAxes=[],this.wheelForces=[]}addWheel(e){void 0===e&&(e={});let t;t=e.body?e.body:new Body({mass:1,shape:new Sphere(1.2)}),this.wheelBodies.push(t),this.wheelForces.push(0);let i=void 0!==e.position?e.position.clone():new Vec3,s=new Vec3;this.chassisBody.pointToWorldFrame(i,s),t.position.set(s.x,s.y,s.z);let o=void 0!==e.axis?e.axis.clone():new Vec3(0,0,1);this.wheelAxes.push(o);let n=new HingeConstraint(this.chassisBody,t,{pivotA:i,axisA:o,pivotB:Vec3.ZERO,axisB:o,collideConnected:!1});return this.constraints.push(n),this.wheelBodies.length-1}setSteeringValue(e,t){let i=this.wheelAxes[t],s=Math.cos(e),o=Math.sin(e),n=i.x,r=i.z;this.constraints[t].axisA.set(-s*n+o*r,0,o*n+s*r)}setMotorSpeed(e,t){let i=this.constraints[t];i.enableMotor(),i.motorTargetVelocity=e}disableMotor(e){let t=this.constraints[e];t.disableMotor()}setWheelForce(e,t){this.wheelForces[t]=e}applyWheelForce(e,t){let i=this.wheelAxes[t],s=this.wheelBodies[t],o=s.torque;i.scale(e,torque),s.vectorToWorldFrame(torque,torque),o.vadd(torque,o)}addToWorld(e){let t=this.constraints,i=this.wheelBodies.concat([this.chassisBody]);for(let s=0;s<i.length;s++)e.addBody(i[s]);for(let o=0;o<t.length;o++)e.addConstraint(t[o]);e.addEventListener("preStep",this._update.bind(this))}_update(){let e=this.wheelForces;for(let t=0;t<e.length;t++)this.applyWheelForce(e[t],t)}removeFromWorld(e){let t=this.constraints,i=this.wheelBodies.concat([this.chassisBody]);for(let s=0;s<i.length;s++)e.removeBody(i[s]);for(let o=0;o<t.length;o++)e.removeConstraint(t[o])}getWheelSpeed(e){let t=this.wheelAxes[e],i=this.wheelBodies[e],s=i.angularVelocity;return this.chassisBody.vectorToWorldFrame(t,worldAxis),s.dot(worldAxis)}}let torque=new Vec3,worldAxis=new Vec3;class SPHSystem{constructor(){this.particles=[],this.density=1,this.smoothingRadius=1,this.speedOfSound=1,this.viscosity=.01,this.eps=1e-6,this.pressures=[],this.densities=[],this.neighbors=[]}add(e){this.particles.push(e),this.neighbors.length<this.particles.length&&this.neighbors.push([])}remove(e){let t=this.particles.indexOf(e);-1!==t&&(this.particles.splice(t,1),this.neighbors.length>this.particles.length&&this.neighbors.pop())}getNeighbors(e,t){let i=this.particles.length,s=e.id,o=this.smoothingRadius*this.smoothingRadius,n=SPHSystem_getNeighbors_dist;for(let r=0;r!==i;r++){let l=this.particles[r];l.position.vsub(e.position,n),s!==l.id&&n.lengthSquared()<o&&t.push(l)}}update(){let e=this.particles.length,t=SPHSystem_update_dist,i=this.speedOfSound,s=this.eps;for(let o=0;o!==e;o++){let n=this.particles[o],r=this.neighbors[o];r.length=0,this.getNeighbors(n,r),r.push(this.particles[o]);let l=r.length,h=0;for(let d=0;d!==l;d++){n.position.vsub(r[d].position,t);let p=t.length(),u=this.w(p);h+=r[d].mass*u}this.densities[o]=h,this.pressures[o]=i*i*(this.densities[o]-this.density)}let m=SPHSystem_update_a_pressure,v=SPHSystem_update_a_visc,$=SPHSystem_update_gradW,y=SPHSystem_update_r_vec,g=SPHSystem_update_u;for(let x=0;x!==e;x++){let f=this.particles[x];m.set(0,0,0),v.set(0,0,0);let w,B,_=this.neighbors[x],S=_.length;for(let V=0;V!==S;V++){let A=_[V];f.position.vsub(A.position,y);let E=y.length();w=-A.mass*(this.pressures[x]/(this.densities[x]*this.densities[x]+s)+this.pressures[V]/(this.densities[V]*this.densities[V]+s)),this.gradw(y,$),$.scale(w,$),m.vadd($,m),A.velocity.vsub(f.velocity,g),g.scale(1/(1e-4+this.densities[x]*this.densities[V])*this.viscosity*A.mass,g),B=this.nablaw(E),g.scale(B,g),v.vadd(g,v)}v.scale(f.mass,v),m.scale(f.mass,m),f.force.vadd(v,f.force),f.force.vadd(m,f.force)}}w(e){let t=this.smoothingRadius;return 315/(64*Math.PI*t**9)*(t*t-e*e)**3}gradw(e,t){let i=e.length(),s=this.smoothingRadius;e.scale(945/(32*Math.PI*s**9)*(s*s-i*i)**2,t)}nablaw(e){let t=this.smoothingRadius;return 945/(32*Math.PI*t**9)*(t*t-e*e)*(7*e*e-3*t*t)}}let SPHSystem_getNeighbors_dist=new Vec3,SPHSystem_update_dist=new Vec3,SPHSystem_update_a_pressure=new Vec3,SPHSystem_update_a_visc=new Vec3,SPHSystem_update_gradW=new Vec3,SPHSystem_update_r_vec=new Vec3,SPHSystem_update_u=new Vec3;class Cylinder extends ConvexPolyhedron{constructor(e,t,i,s){if(void 0===e&&(e=1),void 0===t&&(t=1),void 0===i&&(i=1),void 0===s&&(s=8),e<0)throw Error("The cylinder radiusTop cannot be negative.");if(t<0)throw Error("The cylinder radiusBottom cannot be negative.");let o=s,n=[],r=[],l=[],h=[],d=[],p=Math.cos,u=Math.sin;n.push(new Vec3(-t*u(0),-(.5*i),t*p(0))),h.push(0),n.push(new Vec3(-e*u(0),.5*i,e*p(0))),d.push(1);for(let m=0;m<o;m++){let v=2*Math.PI/o*(m+1),$=2*Math.PI/o*(m+.5);m<o-1?(n.push(new Vec3(-t*u(v),-(.5*i),t*p(v))),h.push(2*m+2),n.push(new Vec3(-e*u(v),.5*i,e*p(v))),d.push(2*m+3),l.push([2*m,2*m+1,2*m+3,2*m+2])):l.push([2*m,2*m+1,1,0]),(o%2==1||m<o/2)&&r.push(new Vec3(-u($),0,p($)))}l.push(h),r.push(new Vec3(0,1,0));let y=[];for(let g=0;g<d.length;g++)y.push(d[d.length-g-1]);l.push(y),super({vertices:n,faces:l,axes:r}),this.type=Shape.types.CYLINDER,this.radiusTop=e,this.radiusBottom=t,this.height=i,this.numSegments=s}}class Particle extends Shape{constructor(){super({type:Shape.types.PARTICLE})}calculateLocalInertia(e,t){return void 0===t&&(t=new Vec3),t.set(0,0,0),t}volume(){return 0}updateBoundingSphereRadius(){this.boundingSphereRadius=0}calculateWorldAABB(e,t,i,s){i.copy(e),s.copy(e)}}class Plane extends Shape{constructor(){super({type:Shape.types.PLANE}),this.worldNormal=new Vec3,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(e){let t=this.worldNormal;t.set(0,0,1),e.vmult(t,t),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(e,t){return void 0===t&&(t=new Vec3),t}volume(){return Number.MAX_VALUE}calculateWorldAABB(e,t,i,s){tempNormal.set(0,0,1),t.vmult(tempNormal,tempNormal);let o=Number.MAX_VALUE;i.set(-o,-o,-o),s.set(o,o,o),1===tempNormal.x?s.x=e.x:-1===tempNormal.x&&(i.x=e.x),1===tempNormal.y?s.y=e.y:-1===tempNormal.y&&(i.y=e.y),1===tempNormal.z?s.z=e.z:-1===tempNormal.z&&(i.z=e.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}let tempNormal=new Vec3;class Heightfield extends Shape{constructor(e,t){void 0===t&&(t={}),t=Utils.defaults(t,{maxValue:null,minValue:null,elementSize:1}),super({type:Shape.types.HEIGHTFIELD}),this.data=e,this.maxValue=t.maxValue,this.minValue=t.minValue,this.elementSize=t.elementSize,null===t.minValue&&this.updateMinValue(),null===t.maxValue&&this.updateMaxValue(),this.cacheEnabled=!0,this.pillarConvex=new ConvexPolyhedron,this.pillarOffset=new Vec3,this.updateBoundingSphereRadius(),this._cachedPillars={}}update(){this._cachedPillars={}}updateMinValue(){let e=this.data,t=e[0][0];for(let i=0;i!==e.length;i++)for(let s=0;s!==e[i].length;s++){let o=e[i][s];o<t&&(t=o)}this.minValue=t}updateMaxValue(){let e=this.data,t=e[0][0];for(let i=0;i!==e.length;i++)for(let s=0;s!==e[i].length;s++){let o=e[i][s];o>t&&(t=o)}this.maxValue=t}setHeightValueAtIndex(e,t,i){let s=this.data;s[e][t]=i,this.clearCachedConvexTrianglePillar(e,t,!1),e>0&&(this.clearCachedConvexTrianglePillar(e-1,t,!0),this.clearCachedConvexTrianglePillar(e-1,t,!1)),t>0&&(this.clearCachedConvexTrianglePillar(e,t-1,!0),this.clearCachedConvexTrianglePillar(e,t-1,!1)),t>0&&e>0&&this.clearCachedConvexTrianglePillar(e-1,t-1,!0)}getRectMinMax(e,t,i,s,o){void 0===o&&(o=[]);let n=this.data,r=this.minValue;for(let l=e;l<=i;l++)for(let h=t;h<=s;h++){let d=n[l][h];d>r&&(r=d)}o[0]=this.minValue,o[1]=r}getIndexOfPosition(e,t,i,s){let o=this.elementSize,n=this.data,r=Math.floor(e/o),l=Math.floor(t/o);return i[0]=r,i[1]=l,s&&(r<0&&(r=0),l<0&&(l=0),r>=n.length-1&&(r=n.length-1),l>=n[0].length-1&&(l=n[0].length-1)),!(r<0)&&!(l<0)&&!(r>=n.length-1)&&!(l>=n[0].length-1)}getTriangleAt(e,t,i,s,o,n){let r=getHeightAt_idx;this.getIndexOfPosition(e,t,r,i);let l=r[0],h=r[1],d=this.data;i&&(l=Math.min(d.length-2,Math.max(0,l)),h=Math.min(d[0].length-2,Math.max(0,h)));let p=this.elementSize,u=(e/p-l)**2+(t/p-h)**2,m=(e/p-(l+1))**2+(t/p-(h+1))**2,v=u>m;return this.getTriangle(l,h,v,s,o,n),v}getNormalAt(e,t,i,s){let o=getNormalAt_a,n=getNormalAt_b,r=getNormalAt_c,l=getNormalAt_e0,h=getNormalAt_e1;this.getTriangleAt(e,t,i,o,n,r),n.vsub(o,l),r.vsub(o,h),l.cross(h,s),s.normalize()}getAabbAtIndex(e,t,i){let{lowerBound:s,upperBound:o}=i,n=this.data,r=this.elementSize;s.set(e*r,t*r,n[e][t]),o.set((e+1)*r,(t+1)*r,n[e+1][t+1])}getHeightAt(e,t,i){let s=this.data,o=getHeightAt_a,n=getHeightAt_b,r=getHeightAt_c,l=getHeightAt_idx;this.getIndexOfPosition(e,t,l,i);let h=l[0],d=l[1];i&&(h=Math.min(s.length-2,Math.max(0,h)),d=Math.min(s[0].length-2,Math.max(0,d)));let p=this.getTriangleAt(e,t,i,o,n,r);barycentricWeights(e,t,o.x,o.y,n.x,n.y,r.x,r.y,getHeightAt_weights);let u=getHeightAt_weights;return p?s[h+1][d+1]*u.x+s[h][d+1]*u.y+s[h+1][d]*u.z:s[h][d]*u.x+s[h+1][d]*u.y+s[h][d+1]*u.z}getCacheConvexTrianglePillarKey(e,t,i){return`${e}_${t}_${i?1:0}`}getCachedConvexTrianglePillar(e,t,i){return this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,t,i)]}setCachedConvexTrianglePillar(e,t,i,s,o){this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,t,i)]={convex:s,offset:o}}clearCachedConvexTrianglePillar(e,t,i){delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,t,i)]}getTriangle(e,t,i,s,o,n){let r=this.data,l=this.elementSize;i?(s.set((e+1)*l,(t+1)*l,r[e+1][t+1]),o.set(e*l,(t+1)*l,r[e][t+1]),n.set((e+1)*l,t*l,r[e+1][t])):(s.set(e*l,t*l,r[e][t]),o.set((e+1)*l,t*l,r[e+1][t]),n.set(e*l,(t+1)*l,r[e][t+1]))}getConvexTrianglePillar(e,t,i){let s=this.pillarConvex,o=this.pillarOffset;if(this.cacheEnabled){let n=this.getCachedConvexTrianglePillar(e,t,i);if(n){this.pillarConvex=n.convex,this.pillarOffset=n.offset;return}s=new ConvexPolyhedron,o=new Vec3,this.pillarConvex=s,this.pillarOffset=o}let r=this.data,l=this.elementSize,h=s.faces;s.vertices.length=6;for(let d=0;d<6;d++)s.vertices[d]||(s.vertices[d]=new Vec3);h.length=5;for(let p=0;p<5;p++)h[p]||(h[p]=[]);let u=s.vertices,m=(Math.min(r[e][t],r[e+1][t],r[e][t+1],r[e+1][t+1])-this.minValue)/2+this.minValue;i?(o.set((e+.75)*l,(t+.75)*l,m),u[0].set(.25*l,.25*l,r[e+1][t+1]-m),u[1].set(-.75*l,.25*l,r[e][t+1]-m),u[2].set(.25*l,-.75*l,r[e+1][t]-m),u[3].set(.25*l,.25*l,-Math.abs(m)-1),u[4].set(-.75*l,.25*l,-Math.abs(m)-1),u[5].set(.25*l,-.75*l,-Math.abs(m)-1),h[0][0]=0,h[0][1]=1,h[0][2]=2,h[1][0]=5,h[1][1]=4,h[1][2]=3,h[2][0]=2,h[2][1]=5,h[2][2]=3,h[2][3]=0,h[3][0]=3,h[3][1]=4,h[3][2]=1,h[3][3]=0,h[4][0]=1,h[4][1]=4,h[4][2]=5,h[4][3]=2):(o.set((e+.25)*l,(t+.25)*l,m),u[0].set(-.25*l,-.25*l,r[e][t]-m),u[1].set(.75*l,-.25*l,r[e+1][t]-m),u[2].set(-.25*l,.75*l,r[e][t+1]-m),u[3].set(-.25*l,-.25*l,-Math.abs(m)-1),u[4].set(.75*l,-.25*l,-Math.abs(m)-1),u[5].set(-.25*l,.75*l,-Math.abs(m)-1),h[0][0]=0,h[0][1]=1,h[0][2]=2,h[1][0]=5,h[1][1]=4,h[1][2]=3,h[2][0]=0,h[2][1]=2,h[2][2]=5,h[2][3]=3,h[3][0]=1,h[3][1]=0,h[3][2]=3,h[3][3]=4,h[4][0]=4,h[4][1]=5,h[4][2]=2,h[4][3]=1),s.computeNormals(),s.computeEdges(),s.updateBoundingSphereRadius(),this.setCachedConvexTrianglePillar(e,t,i,s,o)}calculateLocalInertia(e,t){return void 0===t&&(t=new Vec3),t.set(0,0,0),t}volume(){return Number.MAX_VALUE}calculateWorldAABB(e,t,i,s){i.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),s.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)}updateBoundingSphereRadius(){let e=this.data,t=this.elementSize;this.boundingSphereRadius=new Vec3(e.length*t,e[0].length*t,Math.max(Math.abs(this.maxValue),Math.abs(this.minValue))).length()}setHeightsFromImage(e,t){let{x:i,z:s,y:o}=t,n=document.createElement("canvas");n.width=e.width,n.height=e.height;let r=n.getContext("2d");r.drawImage(e,0,0);let l=r.getImageData(0,0,e.width,e.height),h=this.data;h.length=0,this.elementSize=Math.abs(i)/l.width;for(let d=0;d<l.height;d++){let p=[];for(let u=0;u<l.width;u++){let m=l.data[(d*l.height+u)*4],v=l.data[(d*l.height+u)*4+1],$=l.data[(d*l.height+u)*4+2],y=(m+v+$)/4/255*s;i<0?p.push(y):p.unshift(y)}o<0?h.unshift(p):h.push(p)}this.updateMaxValue(),this.updateMinValue(),this.update()}}let getHeightAt_idx=[],getHeightAt_weights=new Vec3,getHeightAt_a=new Vec3,getHeightAt_b=new Vec3,getHeightAt_c=new Vec3,getNormalAt_a=new Vec3,getNormalAt_b=new Vec3,getNormalAt_c=new Vec3,getNormalAt_e0=new Vec3,getNormalAt_e1=new Vec3;function barycentricWeights(e,t,i,s,o,n,r,l,h){h.x=((n-l)*(e-r)+(r-o)*(t-l))/((n-l)*(i-r)+(r-o)*(s-l)),h.y=((l-s)*(e-r)+(i-r)*(t-l))/((n-l)*(i-r)+(r-o)*(s-l)),h.z=1-h.x-h.y}class OctreeNode{constructor(e){void 0===e&&(e={}),this.root=e.root||null,this.aabb=e.aabb?e.aabb.clone():new AABB,this.data=[],this.children=[]}reset(){this.children.length=this.data.length=0}insert(e,t,i){void 0===i&&(i=0);let s=this.data;if(!this.aabb.contains(e))return!1;let o=this.children,n=this.maxDepth||this.root.maxDepth;if(i<n){let r=!1;o.length||(this.subdivide(),r=!0);for(let l=0;8!==l;l++)if(o[l].insert(e,t,i+1))return!0;r&&(o.length=0)}return s.push(t),!0}subdivide(){let e=this.aabb,t=e.lowerBound,i=e.upperBound,s=this.children;s.push(new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,0,0)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,0,0)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,1,0)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,1,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,1,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,0,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,0,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,1,0)})})),i.vsub(t,halfDiagonal),halfDiagonal.scale(.5,halfDiagonal);let o=this.root||this;for(let n=0;8!==n;n++){let r=s[n];r.root=o;let l=r.aabb.lowerBound;l.x*=halfDiagonal.x,l.y*=halfDiagonal.y,l.z*=halfDiagonal.z,l.vadd(t,l),l.vadd(halfDiagonal,r.aabb.upperBound)}}aabbQuery(e,t){this.data,this.children;let i=[this];for(;i.length;){let s=i.pop();s.aabb.overlaps(e)&&Array.prototype.push.apply(t,s.data),Array.prototype.push.apply(i,s.children)}return t}rayQuery(e,t,i){return e.getAABB(tmpAABB),tmpAABB.toLocalFrame(t,tmpAABB),this.aabbQuery(tmpAABB,i),i}removeEmptyNodes(){for(let e=this.children.length-1;e>=0;e--)this.children[e].removeEmptyNodes(),this.children[e].children.length||this.children[e].data.length||this.children.splice(e,1)}}class Octree extends OctreeNode{constructor(e,t){void 0===t&&(t={}),super({root:null,aabb:e}),this.maxDepth=void 0!==t.maxDepth?t.maxDepth:8}}let halfDiagonal=new Vec3,tmpAABB=new AABB;class Trimesh extends Shape{constructor(e,t){super({type:Shape.types.TRIMESH}),this.vertices=new Float32Array(e),this.indices=new Int16Array(t),this.normals=new Float32Array(t.length),this.aabb=new AABB,this.edges=null,this.scale=new Vec3(1,1,1),this.tree=new Octree,this.updateEdges(),this.updateNormals(),this.updateAABB(),this.updateBoundingSphereRadius(),this.updateTree()}updateTree(){let e=this.tree;e.reset(),e.aabb.copy(this.aabb);let t=this.scale;e.aabb.lowerBound.x*=1/t.x,e.aabb.lowerBound.y*=1/t.y,e.aabb.lowerBound.z*=1/t.z,e.aabb.upperBound.x*=1/t.x,e.aabb.upperBound.y*=1/t.y,e.aabb.upperBound.z*=1/t.z;let i=new AABB,s=new Vec3,o=new Vec3,n=new Vec3,r=[s,o,n];for(let l=0;l<this.indices.length/3;l++){let h=3*l;this._getUnscaledVertex(this.indices[h],s),this._getUnscaledVertex(this.indices[h+1],o),this._getUnscaledVertex(this.indices[h+2],n),i.setFromPoints(r),e.insert(i,l)}e.removeEmptyNodes()}getTrianglesInAABB(e,t){unscaledAABB.copy(e);let i=this.scale,s=i.x,o=i.y,n=i.z,r=unscaledAABB.lowerBound,l=unscaledAABB.upperBound;return r.x/=s,r.y/=o,r.z/=n,l.x/=s,l.y/=o,l.z/=n,this.tree.aabbQuery(unscaledAABB,t)}setScale(e){let t=this.scale.x===this.scale.y&&this.scale.y===this.scale.z,i=e.x===e.y&&e.y===e.z;t&&i||this.updateNormals(),this.scale.copy(e),this.updateAABB(),this.updateBoundingSphereRadius()}updateNormals(){let e=computeNormals_n,t=this.normals;for(let i=0;i<this.indices.length/3;i++){let s=3*i,o=this.indices[s],n=this.indices[s+1],r=this.indices[s+2];this.getVertex(o,va),this.getVertex(n,vb),this.getVertex(r,vc),Trimesh.computeNormal(vb,va,vc,e),t[s]=e.x,t[s+1]=e.y,t[s+2]=e.z}}updateEdges(){let e={},t=(t,i)=>{let s=t<i?`${t}_${i}`:`${i}_${t}`;e[s]=!0};for(let i=0;i<this.indices.length/3;i++){let s=3*i,o=this.indices[s],n=this.indices[s+1],r=this.indices[s+2];t(o,n),t(n,r),t(r,o)}let l=Object.keys(e);this.edges=new Int16Array(2*l.length);for(let h=0;h<l.length;h++){let d=l[h].split("_");this.edges[2*h]=parseInt(d[0],10),this.edges[2*h+1]=parseInt(d[1],10)}}getEdgeVertex(e,t,i){let s=this.edges[2*e+(t?1:0)];this.getVertex(s,i)}getEdgeVector(e,t){let i=getEdgeVector_va,s=getEdgeVector_vb;this.getEdgeVertex(e,0,i),this.getEdgeVertex(e,1,s),s.vsub(i,t)}static computeNormal(e,t,i,s){t.vsub(e,ab),i.vsub(t,cb),cb.cross(ab,s),s.isZero()||s.normalize()}getVertex(e,t){let i=this.scale;return this._getUnscaledVertex(e,t),t.x*=i.x,t.y*=i.y,t.z*=i.z,t}_getUnscaledVertex(e,t){let i=3*e,s=this.vertices;return t.set(s[i],s[i+1],s[i+2])}getWorldVertex(e,t,i,s){return this.getVertex(e,s),Transform.pointToWorldFrame(t,i,s,s),s}getTriangleVertices(e,t,i,s){let o=3*e;this.getVertex(this.indices[o],t),this.getVertex(this.indices[o+1],i),this.getVertex(this.indices[o+2],s)}getNormal(e,t){let i=3*e;return t.set(this.normals[i],this.normals[i+1],this.normals[i+2])}calculateLocalInertia(e,t){this.computeLocalAABB(cli_aabb);let i=cli_aabb.upperBound.x-cli_aabb.lowerBound.x,s=cli_aabb.upperBound.y-cli_aabb.lowerBound.y,o=cli_aabb.upperBound.z-cli_aabb.lowerBound.z;return t.set(1/12*e*(2*s*2*s+2*o*2*o),1/12*e*(2*i*2*i+2*o*2*o),1/12*e*(2*s*2*s+2*i*2*i))}computeLocalAABB(e){let t=e.lowerBound,i=e.upperBound,s=this.vertices.length;this.vertices;let o=computeLocalAABB_worldVert;this.getVertex(0,o),t.copy(o),i.copy(o);for(let n=0;n!==s;n++)this.getVertex(n,o),o.x<t.x?t.x=o.x:o.x>i.x&&(i.x=o.x),o.y<t.y?t.y=o.y:o.y>i.y&&(i.y=o.y),o.z<t.z?t.z=o.z:o.z>i.z&&(i.z=o.z)}updateAABB(){this.computeLocalAABB(this.aabb)}updateBoundingSphereRadius(){let e=0,t=this.vertices,i=new Vec3;for(let s=0,o=t.length/3;s!==o;s++){this.getVertex(s,i);let n=i.lengthSquared();n>e&&(e=n)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,i,s){let o=calculateWorldAABB_frame,n=calculateWorldAABB_aabb;o.position=e,o.quaternion=t,this.aabb.toWorldFrame(o,n),i.copy(n.lowerBound),s.copy(n.upperBound)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}static createTorus(e,t,i,s,o){void 0===e&&(e=1),void 0===t&&(t=.5),void 0===i&&(i=8),void 0===s&&(s=6),void 0===o&&(o=2*Math.PI);let n=[],r=[];for(let l=0;l<=i;l++)for(let h=0;h<=s;h++){let d=h/s*o,p=l/i*Math.PI*2,u=(e+t*Math.cos(p))*Math.cos(d),m=(e+t*Math.cos(p))*Math.sin(d),v=t*Math.sin(p);n.push(u,m,v)}for(let $=1;$<=i;$++)for(let y=1;y<=s;y++){let g=(s+1)*$+y-1,x=(s+1)*($-1)+y-1,f=(s+1)*($-1)+y,w=(s+1)*$+y;r.push(g,x,w),r.push(x,f,w)}return new Trimesh(n,r)}}let computeNormals_n=new Vec3,unscaledAABB=new AABB,getEdgeVector_va=new Vec3,getEdgeVector_vb=new Vec3,cb=new Vec3,ab=new Vec3,va=new Vec3,vb=new Vec3,vc=new Vec3,cli_aabb=new AABB,computeLocalAABB_worldVert=new Vec3,calculateWorldAABB_frame=new Transform,calculateWorldAABB_aabb=new AABB;class Solver{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){!e.enabled||e.bi.isTrigger||e.bj.isTrigger||this.equations.push(e)}removeEquation(e){let t=this.equations,i=t.indexOf(e);-1!==i&&t.splice(i,1)}removeAllEquations(){this.equations.length=0}}class GSSolver extends Solver{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let i=0,s=this.iterations,o=this.tolerance*this.tolerance,n=this.equations,r=n.length,l=t.bodies,h=l.length,d=e,p,u,m,v,$,y;if(0!==r)for(let g=0;g!==h;g++)l[g].updateSolveMassProperties();let x=GSSolver_solve_invCs,f=GSSolver_solve_Bs,w=GSSolver_solve_lambda;x.length=r,f.length=r,w.length=r;for(let B=0;B!==r;B++){let _=n[B];w[B]=0,f[B]=_.computeB(d),x[B]=1/_.computeC()}if(0!==r){for(let S=0;S!==h;S++){let V=l[S],A=V.vlambda,E=V.wlambda;A.set(0,0,0),E.set(0,0,0)}for(i=0;i!==s;i++){v=0;for(let C=0;C!==r;C++){let T=n[C];p=f[C],u=x[C],y=w[C],m=u*(p-($=T.computeGWlambda())-T.eps*y),y+m<T.minForce?m=T.minForce-y:y+m>T.maxForce&&(m=T.maxForce-y),w[C]+=m,v+=m>0?m:-m,T.addToWlambda(m)}if(v*v<o)break}for(let P=0;P!==h;P++){let I=l[P],F=I.velocity,R=I.angularVelocity;I.vlambda.vmul(I.linearFactor,I.vlambda),F.vadd(I.vlambda,F),I.wlambda.vmul(I.angularFactor,I.wlambda),R.vadd(I.wlambda,R)}let z=n.length,q=1/d;for(;z--;)n[z].multiplier=w[z]*q}return i}}let GSSolver_solve_lambda=[],GSSolver_solve_invCs=[],GSSolver_solve_Bs=[];class SplitSolver extends Solver{constructor(e){for(super(),this.iterations=10,this.tolerance=1e-7,this.subsolver=e,this.nodes=[],this.nodePool=[];this.nodePool.length<128;)this.nodePool.push(this.createNode())}createNode(){return{body:null,children:[],eqs:[],visited:!1}}solve(e,t){let i=SplitSolver_solve_nodes,s=this.nodePool,o=t.bodies,n=this.equations,r=n.length,l=o.length,h=this.subsolver;for(;s.length<l;)s.push(this.createNode());i.length=l;for(let d=0;d<l;d++)i[d]=s[d];for(let p=0;p!==l;p++){let u=i[p];u.body=o[p],u.children.length=0,u.eqs.length=0,u.visited=!1}for(let m=0;m!==r;m++){let v=n[m],$=o.indexOf(v.bi),y=o.indexOf(v.bj),g=i[$],x=i[y];g.children.push(x),g.eqs.push(v),x.children.push(g),x.eqs.push(v)}let f,w=0,B=SplitSolver_solve_eqs;h.tolerance=this.tolerance,h.iterations=this.iterations;let _=SplitSolver_solve_dummyWorld;for(;f=getUnvisitedNode(i);){B.length=0,_.bodies.length=0,bfs(f,visitFunc,_.bodies,B);let S=B.length;B=B.sort(sortById);for(let V=0;V!==S;V++)h.addEquation(B[V]);h.solve(e,_),h.removeAllEquations(),w++}return w}}let SplitSolver_solve_nodes=[],SplitSolver_solve_eqs=[],SplitSolver_solve_dummyWorld={bodies:[]},STATIC=Body.STATIC;function getUnvisitedNode(e){let t=e.length;for(let i=0;i!==t;i++){let s=e[i];if(!s.visited&&!(s.body.type&STATIC))return s}return!1}let queue=[];function bfs(e,t,i,s){for(queue.push(e),e.visited=!0,t(e,i,s);queue.length;){let o=queue.pop(),n;for(;n=getUnvisitedNode(o.children);)n.visited=!0,t(n,i,s),queue.push(n)}}function visitFunc(e,t,i){t.push(e.body);let s=e.eqs.length;for(let o=0;o!==s;o++){let n=e.eqs[o];i.includes(n)||i.push(n)}}function sortById(e,t){return t.id-e.id}class Pool{constructor(){this.objects=[],this.type=Object}release(){let e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){let t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class Vec3Pool extends Pool{constructor(){super(...arguments),this.type=Vec3}constructObject(){return new Vec3}}let COLLISION_TYPES={sphereSphere:Shape.types.SPHERE,spherePlane:Shape.types.SPHERE|Shape.types.PLANE,boxBox:Shape.types.BOX|Shape.types.BOX,sphereBox:Shape.types.SPHERE|Shape.types.BOX,planeBox:Shape.types.PLANE|Shape.types.BOX,convexConvex:Shape.types.CONVEXPOLYHEDRON,sphereConvex:Shape.types.SPHERE|Shape.types.CONVEXPOLYHEDRON,planeConvex:Shape.types.PLANE|Shape.types.CONVEXPOLYHEDRON,boxConvex:Shape.types.BOX|Shape.types.CONVEXPOLYHEDRON,sphereHeightfield:Shape.types.SPHERE|Shape.types.HEIGHTFIELD,boxHeightfield:Shape.types.BOX|Shape.types.HEIGHTFIELD,convexHeightfield:Shape.types.CONVEXPOLYHEDRON|Shape.types.HEIGHTFIELD,sphereParticle:Shape.types.PARTICLE|Shape.types.SPHERE,planeParticle:Shape.types.PLANE|Shape.types.PARTICLE,boxParticle:Shape.types.BOX|Shape.types.PARTICLE,convexParticle:Shape.types.PARTICLE|Shape.types.CONVEXPOLYHEDRON,cylinderCylinder:Shape.types.CYLINDER,sphereCylinder:Shape.types.SPHERE|Shape.types.CYLINDER,planeCylinder:Shape.types.PLANE|Shape.types.CYLINDER,boxCylinder:Shape.types.BOX|Shape.types.CYLINDER,convexCylinder:Shape.types.CONVEXPOLYHEDRON|Shape.types.CYLINDER,heightfieldCylinder:Shape.types.HEIGHTFIELD|Shape.types.CYLINDER,particleCylinder:Shape.types.PARTICLE|Shape.types.CYLINDER,sphereTrimesh:Shape.types.SPHERE|Shape.types.TRIMESH,planeTrimesh:Shape.types.PLANE|Shape.types.TRIMESH};class Narrowphase{get[COLLISION_TYPES.sphereSphere](){return this.sphereSphere}get[COLLISION_TYPES.spherePlane](){return this.spherePlane}get[COLLISION_TYPES.boxBox](){return this.boxBox}get[COLLISION_TYPES.sphereBox](){return this.sphereBox}get[COLLISION_TYPES.planeBox](){return this.planeBox}get[COLLISION_TYPES.convexConvex](){return this.convexConvex}get[COLLISION_TYPES.sphereConvex](){return this.sphereConvex}get[COLLISION_TYPES.planeConvex](){return this.planeConvex}get[COLLISION_TYPES.boxConvex](){return this.boxConvex}get[COLLISION_TYPES.sphereHeightfield](){return this.sphereHeightfield}get[COLLISION_TYPES.boxHeightfield](){return this.boxHeightfield}get[COLLISION_TYPES.convexHeightfield](){return this.convexHeightfield}get[COLLISION_TYPES.sphereParticle](){return this.sphereParticle}get[COLLISION_TYPES.planeParticle](){return this.planeParticle}get[COLLISION_TYPES.boxParticle](){return this.boxParticle}get[COLLISION_TYPES.convexParticle](){return this.convexParticle}get[COLLISION_TYPES.cylinderCylinder](){return this.convexConvex}get[COLLISION_TYPES.sphereCylinder](){return this.sphereConvex}get[COLLISION_TYPES.planeCylinder](){return this.planeConvex}get[COLLISION_TYPES.boxCylinder](){return this.boxConvex}get[COLLISION_TYPES.convexCylinder](){return this.convexConvex}get[COLLISION_TYPES.heightfieldCylinder](){return this.heightfieldCylinder}get[COLLISION_TYPES.particleCylinder](){return this.particleCylinder}get[COLLISION_TYPES.sphereTrimesh](){return this.sphereTrimesh}get[COLLISION_TYPES.planeTrimesh](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new Vec3Pool,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,i,s,o,n){let r;this.contactPointPool.length?((r=this.contactPointPool.pop()).bi=e,r.bj=t):r=new ContactEquation(e,t),r.enabled=e.collisionResponse&&t.collisionResponse&&i.collisionResponse&&s.collisionResponse;let l=this.currentContactMaterial;r.restitution=l.restitution,r.setSpookParams(l.contactEquationStiffness,l.contactEquationRelaxation,this.world.dt);let h=i.material||e.material,d=s.material||t.material;return h&&d&&h.restitution>=0&&d.restitution>=0&&(r.restitution=h.restitution*d.restitution),r.si=o||i,r.sj=n||s,r}createFrictionEquationsFromContact(e,t){let i=e.bi,s=e.bj,o=e.si,n=e.sj,r=this.world,l=this.currentContactMaterial,h=l.friction,d=o.material||i.material,p=n.material||s.material;if(d&&p&&d.friction>=0&&p.friction>=0&&(h=d.friction*p.friction),h>0){let u=h*(r.frictionGravity||r.gravity).length(),m=i.invMass+s.invMass;m>0&&(m=1/m);let v=this.frictionEquationPool,$=v.length?v.pop():new FrictionEquation(i,s,u*m),y=v.length?v.pop():new FrictionEquation(i,s,u*m);return $.bi=y.bi=i,$.bj=y.bj=s,$.minForce=y.minForce=-u*m,$.maxForce=y.maxForce=u*m,$.ri.copy(e.ri),$.rj.copy(e.rj),y.ri.copy(e.ri),y.rj.copy(e.rj),e.ni.tangents($.t,y.t),$.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,r.dt),y.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,r.dt),$.enabled=y.enabled=e.enabled,t.push($,y),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||1===e)return;let i=this.frictionResult[this.frictionResult.length-2],s=this.frictionResult[this.frictionResult.length-1];averageNormal.setZero(),averageContactPointA.setZero(),averageContactPointB.setZero();let o=t.bi;t.bj;for(let n=0;n!==e;n++)(t=this.result[this.result.length-1-n]).bi!==o?(averageNormal.vadd(t.ni,averageNormal),averageContactPointA.vadd(t.ri,averageContactPointA),averageContactPointB.vadd(t.rj,averageContactPointB)):(averageNormal.vsub(t.ni,averageNormal),averageContactPointA.vadd(t.rj,averageContactPointA),averageContactPointB.vadd(t.ri,averageContactPointB));let r=1/e;averageContactPointA.scale(r,i.ri),averageContactPointB.scale(r,i.rj),s.ri.copy(i.ri),s.rj.copy(i.rj),averageNormal.normalize(),averageNormal.tangents(i.t,s.t)}getContacts(e,t,i,s,o,n,r){this.contactPointPool=o,this.frictionEquationPool=r,this.result=s,this.frictionResult=n;let l=tmpQuat1,h=tmpQuat2,d=tmpVec1,p=tmpVec2;for(let u=0,m=e.length;u!==m;u++){let v=e[u],$=t[u],y=null;v.material&&$.material&&(y=i.getContactMaterial(v.material,$.material)||null);let g=v.type&Body.KINEMATIC&&$.type&Body.STATIC||v.type&Body.STATIC&&$.type&Body.KINEMATIC||v.type&Body.KINEMATIC&&$.type&Body.KINEMATIC;for(let x=0;x<v.shapes.length;x++){v.quaternion.mult(v.shapeOrientations[x],l),v.quaternion.vmult(v.shapeOffsets[x],d),d.vadd(v.position,d);let f=v.shapes[x];for(let w=0;w<$.shapes.length;w++){$.quaternion.mult($.shapeOrientations[w],h),$.quaternion.vmult($.shapeOffsets[w],p),p.vadd($.position,p);let B=$.shapes[w];if(!(f.collisionFilterMask&B.collisionFilterGroup&&B.collisionFilterMask&f.collisionFilterGroup)||d.distanceTo(p)>f.boundingSphereRadius+B.boundingSphereRadius)continue;let _=null;f.material&&B.material&&(_=i.getContactMaterial(f.material,B.material)||null),this.currentContactMaterial=_||y||i.defaultContactMaterial;let S=f.type|B.type,V=this[S];if(V){let A=!1;(A=f.type<B.type?V.call(this,f,B,d,p,l,h,v,$,f,B,g):V.call(this,B,f,p,d,h,l,$,v,f,B,g))&&g&&(i.shapeOverlapKeeper.set(f.id,B.id),i.bodyOverlapKeeper.set(v.id,$.id))}}}}}sphereSphere(e,t,i,s,o,n,r,l,h,d,p){if(p)return i.distanceSquared(s)<(e.radius+t.radius)**2;let u=this.createContactEquation(r,l,e,t,h,d);s.vsub(i,u.ni),u.ni.normalize(),u.ri.copy(u.ni),u.rj.copy(u.ni),u.ri.scale(e.radius,u.ri),u.rj.scale(-t.radius,u.rj),u.ri.vadd(i,u.ri),u.ri.vsub(r.position,u.ri),u.rj.vadd(s,u.rj),u.rj.vsub(l.position,u.rj),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}spherePlane(e,t,i,s,o,n,r,l,h,d,p){let u=this.createContactEquation(r,l,e,t,h,d);if(u.ni.set(0,0,1),n.vmult(u.ni,u.ni),u.ni.negate(u.ni),u.ni.normalize(),u.ni.scale(e.radius,u.ri),i.vsub(s,point_on_plane_to_sphere),u.ni.scale(u.ni.dot(point_on_plane_to_sphere),plane_to_sphere_ortho),point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,u.rj),-point_on_plane_to_sphere.dot(u.ni)<=e.radius){if(p)return!0;let m=u.ri,v=u.rj;m.vadd(i,m),m.vsub(r.position,m),v.vadd(s,v),v.vsub(l.position,v),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}}boxBox(e,t,i,s,o,n,r,l,h,d,p){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,i,s,o,n,r,l,e,t,p)}sphereBox(e,t,i,s,o,n,r,l,h,d,p){let u=this.v3pool,m=sphereBox_sides;i.vsub(s,box_to_sphere),t.getSideNormals(m,n);let v=e.radius,$=!1,y=sphereBox_side_ns,g=sphereBox_side_ns1,x=sphereBox_side_ns2,f=null,w=0,B=0,_=0,S=null;for(let V=0,A=m.length;V!==A&&!1===$;V++){let E=sphereBox_ns;E.copy(m[V]);let C=E.length();E.normalize();let T=box_to_sphere.dot(E);if(T<C+v&&T>0){let P=sphereBox_ns1,I=sphereBox_ns2;P.copy(m[(V+1)%3]),I.copy(m[(V+2)%3]);let F=P.length(),R=I.length();P.normalize(),I.normalize();let z=box_to_sphere.dot(P),q=box_to_sphere.dot(I);if(z<F&&z>-F&&q<R&&q>-R){let N=Math.abs(T-C-v);if((null===S||N<S)&&(S=N,B=z,_=q,f=C,y.copy(E),g.copy(P),x.copy(I),w++,p))return!0}}}if(w){$=!0;let L=this.createContactEquation(r,l,e,t,h,d);y.scale(-v,L.ri),L.ni.copy(y),L.ni.negate(L.ni),y.scale(f,y),g.scale(B,g),y.vadd(g,y),x.scale(_,x),y.vadd(x,L.rj),L.ri.vadd(i,L.ri),L.ri.vsub(r.position,L.ri),L.rj.vadd(s,L.rj),L.rj.vsub(l.position,L.rj),this.result.push(L),this.createFrictionEquationsFromContact(L,this.frictionResult)}let W=u.get(),O=sphereBox_sphere_to_corner;for(let M=0;2!==M&&!$;M++)for(let j=0;2!==j&&!$;j++)for(let H=0;2!==H&&!$;H++)if(W.set(0,0,0),M?W.vadd(m[0],W):W.vsub(m[0],W),j?W.vadd(m[1],W):W.vsub(m[1],W),H?W.vadd(m[2],W):W.vsub(m[2],W),s.vadd(W,O),O.vsub(i,O),O.lengthSquared()<v*v){if(p)return!0;$=!0;let k=this.createContactEquation(r,l,e,t,h,d);k.ri.copy(O),k.ri.normalize(),k.ni.copy(k.ri),k.ri.scale(v,k.ri),k.rj.copy(W),k.ri.vadd(i,k.ri),k.ri.vsub(r.position,k.ri),k.rj.vadd(s,k.rj),k.rj.vsub(l.position,k.rj),this.result.push(k),this.createFrictionEquationsFromContact(k,this.frictionResult)}u.release(W),W=null;let D=u.get(),Y=u.get(),U=u.get(),G=u.get(),X=u.get(),Q=m.length;for(let K=0;K!==Q&&!$;K++)for(let Z=0;Z!==Q&&!$;Z++)if(K%3!=Z%3){m[Z].cross(m[K],D),D.normalize(),m[K].vadd(m[Z],Y),U.copy(i),U.vsub(Y,U),U.vsub(s,U);let J=U.dot(D);D.scale(J,G);let ee=0;for(;ee===K%3||ee===Z%3;)ee++;X.copy(i),X.vsub(G,X),X.vsub(Y,X),X.vsub(s,X);let et=Math.abs(J),ei=X.length();if(et<m[ee].length()&&ei<v){if(p)return!0;$=!0;let es=this.createContactEquation(r,l,e,t,h,d);Y.vadd(G,es.rj),es.rj.copy(es.rj),X.negate(es.ni),es.ni.normalize(),es.ri.copy(es.rj),es.ri.vadd(s,es.ri),es.ri.vsub(i,es.ri),es.ri.normalize(),es.ri.scale(v,es.ri),es.ri.vadd(i,es.ri),es.ri.vsub(r.position,es.ri),es.rj.vadd(s,es.rj),es.rj.vsub(l.position,es.rj),this.result.push(es),this.createFrictionEquationsFromContact(es,this.frictionResult)}}u.release(D,Y,U,G,X)}planeBox(e,t,i,s,o,n,r,l,h,d,p){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,i,s,o,n,r,l,e,t,p)}convexConvex(e,t,i,s,o,n,r,l,h,d,p,u,m){let v=convexConvex_sepAxis;if(!(i.distanceTo(s)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,i,o,s,n,v,u,m)){let $=[],y=convexConvex_q;e.clipAgainstHull(i,o,t,s,n,v,-100,100,$);let g=0;for(let x=0;x!==$.length;x++){if(p)return!0;let f=this.createContactEquation(r,l,e,t,h,d),w=f.ri,B=f.rj;v.negate(f.ni),$[x].normal.negate(y),y.scale($[x].depth,y),$[x].point.vadd(y,w),B.copy($[x].point),w.vsub(i,w),B.vsub(s,B),w.vadd(i,w),w.vsub(r.position,w),B.vadd(s,B),B.vsub(l.position,B),this.result.push(f),g++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(f,this.frictionResult)}this.enableFrictionReduction&&g&&this.createFrictionFromAverage(g)}}sphereConvex(e,t,i,s,o,n,r,l,h,d,p){let u=this.v3pool;i.vsub(s,convex_to_sphere);let m=t.faceNormals,v=t.faces,$=t.vertices,y=e.radius,g=!1;for(let x=0;x!==$.length;x++){let f=$[x],w=sphereConvex_worldCorner;n.vmult(f,w),s.vadd(w,w);let B=sphereConvex_sphereToCorner;if(w.vsub(i,B),B.lengthSquared()<y*y){if(p)return!0;g=!0;let _=this.createContactEquation(r,l,e,t,h,d);_.ri.copy(B),_.ri.normalize(),_.ni.copy(_.ri),_.ri.scale(y,_.ri),w.vsub(s,_.rj),_.ri.vadd(i,_.ri),_.ri.vsub(r.position,_.ri),_.rj.vadd(s,_.rj),_.rj.vsub(l.position,_.rj),this.result.push(_),this.createFrictionEquationsFromContact(_,this.frictionResult);return}}for(let S=0,V=v.length;S!==V&&!1===g;S++){let A=m[S],E=v[S],C=sphereConvex_worldNormal;n.vmult(A,C);let T=sphereConvex_worldPoint;n.vmult($[E[0]],T),T.vadd(s,T);let P=sphereConvex_worldSpherePointClosestToPlane;C.scale(-y,P),i.vadd(P,P);let I=sphereConvex_penetrationVec;P.vsub(T,I);let F=I.dot(C),R=sphereConvex_sphereToWorldPoint;if(i.vsub(T,R),F<0&&R.dot(C)>0){let z=[];for(let q=0,N=E.length;q!==N;q++){let L=u.get();n.vmult($[E[q]],L),s.vadd(L,L),z.push(L)}if(pointInPolygon(z,C,i)){if(p)return!0;g=!0;let W=this.createContactEquation(r,l,e,t,h,d);C.scale(-y,W.ri),C.negate(W.ni);let O=u.get();C.scale(-F,O);let M=u.get();C.scale(-y,M),i.vsub(s,W.rj),W.rj.vadd(M,W.rj),W.rj.vadd(O,W.rj),W.rj.vadd(s,W.rj),W.rj.vsub(l.position,W.rj),W.ri.vadd(i,W.ri),W.ri.vsub(r.position,W.ri),u.release(O),u.release(M),this.result.push(W),this.createFrictionEquationsFromContact(W,this.frictionResult);for(let j=0,H=z.length;j!==H;j++)u.release(z[j]);return}for(let k=0;k!==E.length;k++){let D=u.get(),Y=u.get();n.vmult($[E[(k+1)%E.length]],D),n.vmult($[E[(k+2)%E.length]],Y),s.vadd(D,D),s.vadd(Y,Y);let U=sphereConvex_edge;Y.vsub(D,U);let G=sphereConvex_edgeUnit;U.unit(G);let X=u.get(),Q=u.get();i.vsub(D,Q);let K=Q.dot(G);G.scale(K,X),X.vadd(D,X);let Z=u.get();if(X.vsub(i,Z),K>0&&K*K<U.lengthSquared()&&Z.lengthSquared()<y*y){if(p)return!0;let J=this.createContactEquation(r,l,e,t,h,d);X.vsub(s,J.rj),X.vsub(i,J.ni),J.ni.normalize(),J.ni.scale(y,J.ri),J.rj.vadd(s,J.rj),J.rj.vsub(l.position,J.rj),J.ri.vadd(i,J.ri),J.ri.vsub(r.position,J.ri),this.result.push(J),this.createFrictionEquationsFromContact(J,this.frictionResult);for(let ee=0,et=z.length;ee!==et;ee++)u.release(z[ee]);u.release(D),u.release(Y),u.release(X),u.release(Z),u.release(Q);return}u.release(D),u.release(Y),u.release(X),u.release(Z),u.release(Q)}for(let ei=0,es=z.length;ei!==es;ei++)u.release(z[ei])}}}planeConvex(e,t,i,s,o,n,r,l,h,d,p){let u=planeConvex_v,m=planeConvex_normal;m.set(0,0,1),o.vmult(m,m);let v=0,$=planeConvex_relpos;for(let y=0;y!==t.vertices.length;y++){u.copy(t.vertices[y]),n.vmult(u,u),s.vadd(u,u),u.vsub(i,$);let g=m.dot($);if(g<=0){if(p)return!0;let x=this.createContactEquation(r,l,e,t,h,d),f=planeConvex_projected;m.scale(m.dot($),f),u.vsub(f,f),f.vsub(i,x.ri),x.ni.copy(m),u.vsub(s,x.rj),x.ri.vadd(i,x.ri),x.ri.vsub(r.position,x.ri),x.rj.vadd(s,x.rj),x.rj.vsub(l.position,x.rj),this.result.push(x),v++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(x,this.frictionResult)}}this.enableFrictionReduction&&v&&this.createFrictionFromAverage(v)}boxConvex(e,t,i,s,o,n,r,l,h,d,p){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,i,s,o,n,r,l,e,t,p)}sphereHeightfield(e,t,i,s,o,n,r,l,h,d,p){let u=t.data,m=e.radius,v=t.elementSize,$=sphereHeightfield_tmp2,y=sphereHeightfield_tmp1;Transform.pointToLocalFrame(s,n,i,y);let g=Math.floor((y.x-m)/v)-1,x=Math.ceil((y.x+m)/v)+1,f=Math.floor((y.y-m)/v)-1,w=Math.ceil((y.y+m)/v)+1;if(x<0||w<0||g>u.length||f>u[0].length)return;g<0&&(g=0),x<0&&(x=0),f<0&&(f=0),w<0&&(w=0),g>=u.length&&(g=u.length-1),x>=u.length&&(x=u.length-1),w>=u[0].length&&(w=u[0].length-1),f>=u[0].length&&(f=u[0].length-1);let B=[];t.getRectMinMax(g,f,x,w,B);let _=B[0],S=B[1];if(y.z-m>S||y.z+m<_)return;let V=this.result;for(let A=g;A<x;A++)for(let E=f;E<w;E++){let C=V.length,T=!1;if(t.getConvexTrianglePillar(A,E,!1),Transform.pointToWorldFrame(s,n,t.pillarOffset,$),i.distanceTo($)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(T=this.sphereConvex(e,t.pillarConvex,i,$,o,n,r,l,e,t,p)),p&&T||(t.getConvexTrianglePillar(A,E,!0),Transform.pointToWorldFrame(s,n,t.pillarOffset,$),i.distanceTo($)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(T=this.sphereConvex(e,t.pillarConvex,i,$,o,n,r,l,e,t,p)),p&&T))return!0;let P=V.length-C;if(P>2)return}}boxHeightfield(e,t,i,s,o,n,r,l,h,d,p){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,i,s,o,n,r,l,e,t,p)}convexHeightfield(e,t,i,s,o,n,r,l,h,d,p){let u=t.data,m=t.elementSize,v=e.boundingSphereRadius,$=convexHeightfield_tmp2,y=convexHeightfield_faceList,g=convexHeightfield_tmp1;Transform.pointToLocalFrame(s,n,i,g);let x=Math.floor((g.x-v)/m)-1,f=Math.ceil((g.x+v)/m)+1,w=Math.floor((g.y-v)/m)-1,B=Math.ceil((g.y+v)/m)+1;if(f<0||B<0||x>u.length||w>u[0].length)return;x<0&&(x=0),f<0&&(f=0),w<0&&(w=0),B<0&&(B=0),x>=u.length&&(x=u.length-1),f>=u.length&&(f=u.length-1),B>=u[0].length&&(B=u[0].length-1),w>=u[0].length&&(w=u[0].length-1);let _=[];t.getRectMinMax(x,w,f,B,_);let S=_[0],V=_[1];if(!(g.z-v>V)&&!(g.z+v<S))for(let A=x;A<f;A++)for(let E=w;E<B;E++){let C=!1;if(t.getConvexTrianglePillar(A,E,!1),Transform.pointToWorldFrame(s,n,t.pillarOffset,$),i.distanceTo($)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(C=this.convexConvex(e,t.pillarConvex,i,$,o,n,r,l,null,null,p,y,null)),p&&C||(t.getConvexTrianglePillar(A,E,!0),Transform.pointToWorldFrame(s,n,t.pillarOffset,$),i.distanceTo($)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(C=this.convexConvex(e,t.pillarConvex,i,$,o,n,r,l,null,null,p,y,null)),p&&C))return!0}}sphereParticle(e,t,i,s,o,n,r,l,h,d,p){let u=particleSphere_normal;u.set(0,0,1),s.vsub(i,u);let m=u.lengthSquared();if(m<=e.radius*e.radius){if(p)return!0;let v=this.createContactEquation(l,r,t,e,h,d);u.normalize(),v.rj.copy(u),v.rj.scale(e.radius,v.rj),v.ni.copy(u),v.ni.negate(v.ni),v.ri.set(0,0,0),this.result.push(v),this.createFrictionEquationsFromContact(v,this.frictionResult)}}planeParticle(e,t,i,s,o,n,r,l,h,d,p){let u=particlePlane_normal;u.set(0,0,1),r.quaternion.vmult(u,u);let m=particlePlane_relpos;s.vsub(r.position,m);let v=u.dot(m);if(v<=0){if(p)return!0;let $=this.createContactEquation(l,r,t,e,h,d);$.ni.copy(u),$.ni.negate($.ni),$.ri.set(0,0,0);let y=particlePlane_projected;u.scale(u.dot(s),y),s.vsub(y,y),$.rj.copy(y),this.result.push($),this.createFrictionEquationsFromContact($,this.frictionResult)}}boxParticle(e,t,i,s,o,n,r,l,h,d,p){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,i,s,o,n,r,l,e,t,p)}convexParticle(e,t,i,s,o,n,r,l,h,d,p){let u=-1,m=convexParticle_penetratedFaceNormal,v=convexParticle_worldPenetrationVec,$=null,y=convexParticle_local;if(y.copy(s),y.vsub(i,y),o.conjugate(cqj),cqj.vmult(y,y),e.pointIsInside(y)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(i,o),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(o);for(let g=0,x=e.faces.length;g!==x;g++){let f=[e.worldVertices[e.faces[g][0]]],w=e.worldFaceNormals[g];s.vsub(f[0],convexParticle_vertexToParticle);let B=-w.dot(convexParticle_vertexToParticle);if(null===$||Math.abs(B)<Math.abs($)){if(p)return!0;$=B,u=g,m.copy(w)}}if(-1!==u){let _=this.createContactEquation(l,r,t,e,h,d);m.scale($,v),v.vadd(s,v),v.vsub(i,v),_.rj.copy(v),m.negate(_.ni),_.ri.set(0,0,0);let S=_.ri,V=_.rj;S.vadd(s,S),S.vsub(l.position,S),V.vadd(i,V),V.vsub(r.position,V),this.result.push(_),this.createFrictionEquationsFromContact(_,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,i,s,o,n,r,l,h,d,p){return this.convexHeightfield(t,e,s,i,n,o,l,r,h,d,p)}particleCylinder(e,t,i,s,o,n,r,l,h,d,p){return this.convexParticle(t,e,s,i,n,o,l,r,h,d,p)}sphereTrimesh(e,t,i,s,o,n,r,l,h,d,p){let u=sphereTrimesh_edgeVertexA,m=sphereTrimesh_edgeVertexB,v=sphereTrimesh_edgeVector,$=sphereTrimesh_edgeVectorUnit,y=sphereTrimesh_localSpherePos,g=sphereTrimesh_tmp,x=sphereTrimesh_localSphereAABB,f=sphereTrimesh_v2,w=sphereTrimesh_relpos,B=sphereTrimesh_triangles;Transform.pointToLocalFrame(s,n,i,y);let _=e.radius;x.lowerBound.set(y.x-_,y.y-_,y.z-_),x.upperBound.set(y.x+_,y.y+_,y.z+_),t.getTrianglesInAABB(x,B);let S=sphereTrimesh_v,V=e.radius*e.radius;for(let A=0;A<B.length;A++)for(let E=0;E<3;E++)if(t.getVertex(t.indices[3*B[A]+E],S),S.vsub(y,w),w.lengthSquared()<=V){if(f.copy(S),Transform.pointToWorldFrame(s,n,f,S),S.vsub(i,w),p)return!0;let C=this.createContactEquation(r,l,e,t,h,d);C.ni.copy(w),C.ni.normalize(),C.ri.copy(C.ni),C.ri.scale(e.radius,C.ri),C.ri.vadd(i,C.ri),C.ri.vsub(r.position,C.ri),C.rj.copy(S),C.rj.vsub(l.position,C.rj),this.result.push(C),this.createFrictionEquationsFromContact(C,this.frictionResult)}for(let T=0;T<B.length;T++)for(let P=0;P<3;P++){t.getVertex(t.indices[3*B[T]+P],u),t.getVertex(t.indices[3*B[T]+(P+1)%3],m),m.vsub(u,v),y.vsub(m,g);let I=g.dot(v);y.vsub(u,g);let F=g.dot(v);if(F>0&&I<0){y.vsub(u,g),$.copy(v),$.normalize(),F=g.dot($),$.scale(F,g),g.vadd(u,g);let R=g.distanceTo(y);if(R<e.radius){if(p)return!0;let z=this.createContactEquation(r,l,e,t,h,d);g.vsub(y,z.ni),z.ni.normalize(),z.ni.scale(e.radius,z.ri),z.ri.vadd(i,z.ri),z.ri.vsub(r.position,z.ri),Transform.pointToWorldFrame(s,n,g,g),g.vsub(l.position,z.rj),Transform.vectorToWorldFrame(n,z.ni,z.ni),Transform.vectorToWorldFrame(n,z.ri,z.ri),this.result.push(z),this.createFrictionEquationsFromContact(z,this.frictionResult)}}}let q=sphereTrimesh_va,N=sphereTrimesh_vb,L=sphereTrimesh_vc,W=sphereTrimesh_normal;for(let O=0,M=B.length;O!==M;O++){t.getTriangleVertices(B[O],q,N,L),t.getNormal(B[O],W),y.vsub(q,g);let j=g.dot(W);if(W.scale(j,g),y.vsub(g,g),j=g.distanceTo(y),Ray.pointInTriangle(g,q,N,L)&&j<e.radius){if(p)return!0;let H=this.createContactEquation(r,l,e,t,h,d);g.vsub(y,H.ni),H.ni.normalize(),H.ni.scale(e.radius,H.ri),H.ri.vadd(i,H.ri),H.ri.vsub(r.position,H.ri),Transform.pointToWorldFrame(s,n,g,g),g.vsub(l.position,H.rj),Transform.vectorToWorldFrame(n,H.ni,H.ni),Transform.vectorToWorldFrame(n,H.ri,H.ri),this.result.push(H),this.createFrictionEquationsFromContact(H,this.frictionResult)}}B.length=0}planeTrimesh(e,t,i,s,o,n,r,l,h,d,p){let u=new Vec3,m=planeTrimesh_normal;m.set(0,0,1),o.vmult(m,m);for(let v=0;v<t.vertices.length/3;v++){t.getVertex(v,u);let $=new Vec3;$.copy(u),Transform.pointToWorldFrame(s,n,$,u);let y=planeTrimesh_relpos;u.vsub(i,y);let g=m.dot(y);if(g<=0){if(p)return!0;let x=this.createContactEquation(r,l,e,t,h,d);x.ni.copy(m);let f=planeTrimesh_projected;m.scale(y.dot(m),f),u.vsub(f,f),x.ri.copy(f),x.ri.vsub(r.position,x.ri),x.rj.copy(u),x.rj.vsub(l.position,x.rj),this.result.push(x),this.createFrictionEquationsFromContact(x,this.frictionResult)}}}}let averageNormal=new Vec3,averageContactPointA=new Vec3,averageContactPointB=new Vec3,tmpVec1=new Vec3,tmpVec2=new Vec3,tmpQuat1=new Quaternion,tmpQuat2=new Quaternion,planeTrimesh_normal=new Vec3,planeTrimesh_relpos=new Vec3,planeTrimesh_projected=new Vec3,sphereTrimesh_normal=new Vec3,sphereTrimesh_relpos=new Vec3;new Vec3;let sphereTrimesh_v=new Vec3,sphereTrimesh_v2=new Vec3,sphereTrimesh_edgeVertexA=new Vec3,sphereTrimesh_edgeVertexB=new Vec3,sphereTrimesh_edgeVector=new Vec3,sphereTrimesh_edgeVectorUnit=new Vec3,sphereTrimesh_localSpherePos=new Vec3,sphereTrimesh_tmp=new Vec3,sphereTrimesh_va=new Vec3,sphereTrimesh_vb=new Vec3,sphereTrimesh_vc=new Vec3,sphereTrimesh_localSphereAABB=new AABB,sphereTrimesh_triangles=[],point_on_plane_to_sphere=new Vec3,plane_to_sphere_ortho=new Vec3,pointInPolygon_edge=new Vec3,pointInPolygon_edge_x_normal=new Vec3,pointInPolygon_vtp=new Vec3;function pointInPolygon(e,t,i){let s=null,o=e.length;for(let n=0;n!==o;n++){let r=e[n],l=pointInPolygon_edge;e[(n+1)%o].vsub(r,l);let h=pointInPolygon_edge_x_normal;l.cross(t,h);let d=pointInPolygon_vtp;i.vsub(r,d);let p=h.dot(d);if(null!==s&&(!(p>0)||!0!==s)&&(!(p<=0)||!1!==s))return!1;null===s&&(s=p>0)}return!0}let box_to_sphere=new Vec3,sphereBox_ns=new Vec3,sphereBox_ns1=new Vec3,sphereBox_ns2=new Vec3,sphereBox_sides=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3],sphereBox_sphere_to_corner=new Vec3,sphereBox_side_ns=new Vec3,sphereBox_side_ns1=new Vec3,sphereBox_side_ns2=new Vec3,convex_to_sphere=new Vec3,sphereConvex_edge=new Vec3,sphereConvex_edgeUnit=new Vec3,sphereConvex_sphereToCorner=new Vec3,sphereConvex_worldCorner=new Vec3,sphereConvex_worldNormal=new Vec3,sphereConvex_worldPoint=new Vec3,sphereConvex_worldSpherePointClosestToPlane=new Vec3,sphereConvex_penetrationVec=new Vec3,sphereConvex_sphereToWorldPoint=new Vec3;new Vec3,new Vec3;let planeConvex_v=new Vec3,planeConvex_normal=new Vec3,planeConvex_relpos=new Vec3,planeConvex_projected=new Vec3,convexConvex_sepAxis=new Vec3,convexConvex_q=new Vec3,particlePlane_normal=new Vec3,particlePlane_relpos=new Vec3,particlePlane_projected=new Vec3,particleSphere_normal=new Vec3,cqj=new Quaternion,convexParticle_local=new Vec3;new Vec3;let convexParticle_penetratedFaceNormal=new Vec3,convexParticle_vertexToParticle=new Vec3,convexParticle_worldPenetrationVec=new Vec3,convexHeightfield_tmp1=new Vec3,convexHeightfield_tmp2=new Vec3,convexHeightfield_faceList=[0],sphereHeightfield_tmp1=new Vec3,sphereHeightfield_tmp2=new Vec3;class OverlapKeeper{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){let i=t;t=e,e=i}return e<<16|t}set(e,t){let i=this.getKey(e,t),s=this.current,o=0;for(;i>s[o];)o++;if(i!==s[o]){for(let n=s.length-1;n>=o;n--)s[n+1]=s[n];s[o]=i}}tick(){let e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){let i=this.current,s=this.previous,o=i.length,n=s.length,r=0;for(let l=0;l<o;l++){let h=!1,d=i[l];for(;d>s[r];)r++;(h=d===s[r])||unpackAndPush(e,d)}r=0;for(let p=0;p<n;p++){let u=!1,m=s[p];for(;m>i[r];)r++;(u=i[r]===m)||unpackAndPush(t,m)}}}function unpackAndPush(e,t){e.push((4294901760&t)>>16,65535&t)}let getKey=(e,t)=>e<t?`${e}-${t}`:`${t}-${e}`;class TupleDictionary{constructor(){this.data={keys:[]}}get(e,t){let i=getKey(e,t);return this.data[i]}set(e,t,i){let s=getKey(e,t);this.get(e,t)||this.data.keys.push(s),this.data[s]=i}delete(e,t){let i=getKey(e,t),s=this.data.keys.indexOf(i);-1!==s&&this.data.keys.splice(s,1),delete this.data[i]}reset(){let e=this.data,t=e.keys;for(;t.length>0;){let i=t.pop();delete e[i]}}}class World extends EventTarget{constructor(e){void 0===e&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==e.quatNormalizeSkip?e.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==e.quatNormalizeFast&&e.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new Vec3,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new Vec3,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=void 0!==e.broadphase?e.broadphase:new NaiveBroadphase,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==e.solver?e.solver:new GSSolver,this.constraints=[],this.narrowphase=new Narrowphase(this),this.collisionMatrix=new ArrayCollisionMatrix,this.collisionMatrixPrevious=new ArrayCollisionMatrix,this.bodyOverlapKeeper=new OverlapKeeper,this.shapeOverlapKeeper=new OverlapKeeper,this.contactmaterials=[],this.contactMaterialTable=new TupleDictionary,this.defaultMaterial=new Material("default"),this.defaultContactMaterial=new ContactMaterial(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){let e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){let t=this.constraints.indexOf(e);-1!==t&&this.constraints.splice(t,1)}rayTest(e,t,i){i instanceof RaycastResult?this.raycastClosest(e,t,{skipBackfaces:!0},i):this.raycastAll(e,t,{skipBackfaces:!0},i)}raycastAll(e,t,i,s){return void 0===i&&(i={}),i.mode=Ray.ALL,i.from=e,i.to=t,i.callback=s,tmpRay.intersectWorld(this,i)}raycastAny(e,t,i,s){return void 0===i&&(i={}),i.mode=Ray.ANY,i.from=e,i.to=t,i.result=s,tmpRay.intersectWorld(this,i)}raycastClosest(e,t,i,s){return void 0===i&&(i={}),i.mode=Ray.CLOSEST,i.from=e,i.to=t,i.result=s,tmpRay.intersectWorld(this,i)}addBody(e){!this.bodies.includes(e)&&(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof Body&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;let t=this.bodies.length-1,i=this.bodies,s=i.indexOf(e);if(-1!==s){i.splice(s,1);for(let o=0;o!==i.length;o++)i[o].index=o;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){let t=this.bodies;for(let i=0;i<t.length;i++){let s=t[i].shapes;for(let o=0;o<s.length;o++){let n=s[o];if(n.id===e)return n}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){let t=this.contactmaterials.indexOf(e);-1!==t&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){void 0===e&&(e=1/60),void 0===t&&(t=10);let i=performance.now()/1e3;if(this.lastCallTime){let s=i-this.lastCallTime;this.step(e,s,t)}else this.step(e,void 0,t);this.lastCallTime=i}step(e,t,i){if(void 0===i&&(i=10),void 0===t)this.internalStep(e),this.time+=e;else{this.accumulator+=t;let s=performance.now(),o=0;for(;this.accumulator>=e&&o<i&&(this.internalStep(e),this.accumulator-=e,o++,!(performance.now()-s>1e3*e)););this.accumulator=this.accumulator%e;let n=this.accumulator/e;for(let r=0;r!==this.bodies.length;r++){let l=this.bodies[r];l.previousPosition.lerp(l.position,n,l.interpolatedPosition),l.previousQuaternion.slerp(l.quaternion,n,l.interpolatedQuaternion),l.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;let t=this.contacts,i=World_step_p1,s=World_step_p2,o=this.bodies.length,n=this.bodies,r=this.solver,l=this.gravity,h=this.doProfiling,d=this.profile,p=Body.DYNAMIC,u=-1/0,m=this.constraints,v=World_step_frictionEquationPool;l.length();let $=l.x,y=l.y,g=l.z,x=0;for(h&&(u=performance.now()),x=0;x!==o;x++){let f=n[x];if(f.type===p){let w=f.force,B=f.mass;w.x+=B*$,w.y+=B*y,w.z+=B*g}}for(let _=0,S=this.subsystems.length;_!==S;_++)this.subsystems[_].update();h&&(u=performance.now()),i.length=0,s.length=0,this.broadphase.collisionPairs(this,i,s),h&&(d.broadphase=performance.now()-u);let V=m.length;for(x=0;x!==V;x++){let A=m[x];if(!A.collideConnected)for(let E=i.length-1;E>=0;E-=1)(A.bodyA===i[E]&&A.bodyB===s[E]||A.bodyB===i[E]&&A.bodyA===s[E])&&(i.splice(E,1),s.splice(E,1))}this.collisionMatrixTick(),h&&(u=performance.now());let C=World_step_oldContacts,T=t.length;for(x=0;x!==T;x++)C.push(t[x]);t.length=0;let P=this.frictionEquations.length;for(x=0;x!==P;x++)v.push(this.frictionEquations[x]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(i,s,this,t,C,this.frictionEquations,v),h&&(d.narrowphase=performance.now()-u),h&&(u=performance.now()),x=0;x<this.frictionEquations.length;x++)r.addEquation(this.frictionEquations[x]);let I=t.length;for(let F=0;F!==I;F++){let R=t[F],z=R.bi,q=R.bj,N=R.si,L=R.sj,W;if((W=z.material&&q.material&&this.getContactMaterial(z.material,q.material)||this.defaultContactMaterial).friction,z.material&&q.material&&(z.material.friction>=0&&q.material.friction>=0&&(z.material.friction,q.material.friction),z.material.restitution>=0&&q.material.restitution>=0&&(R.restitution=z.material.restitution*q.material.restitution)),r.addEquation(R),z.allowSleep&&z.type===Body.DYNAMIC&&z.sleepState===Body.SLEEPING&&q.sleepState===Body.AWAKE&&q.type!==Body.STATIC){let O=q.velocity.lengthSquared()+q.angularVelocity.lengthSquared(),M=q.sleepSpeedLimit**2;O>=2*M&&(z.wakeUpAfterNarrowphase=!0)}if(q.allowSleep&&q.type===Body.DYNAMIC&&q.sleepState===Body.SLEEPING&&z.sleepState===Body.AWAKE&&z.type!==Body.STATIC){let j=z.velocity.lengthSquared()+z.angularVelocity.lengthSquared(),H=z.sleepSpeedLimit**2;j>=2*H&&(q.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(z,q,!0),this.collisionMatrixPrevious.get(z,q)||(World_step_collideEvent.body=q,World_step_collideEvent.contact=R,z.dispatchEvent(World_step_collideEvent),World_step_collideEvent.body=z,q.dispatchEvent(World_step_collideEvent)),this.bodyOverlapKeeper.set(z.id,q.id),this.shapeOverlapKeeper.set(N.id,L.id)}for(this.emitContactEvents(),h&&(d.makeContactConstraints=performance.now()-u,u=performance.now()),x=0;x!==o;x++){let k=n[x];k.wakeUpAfterNarrowphase&&(k.wakeUp(),k.wakeUpAfterNarrowphase=!1)}for(x=0,V=m.length;x!==V;x++){let D=m[x];D.update();for(let Y=0,U=D.equations.length;Y!==U;Y++){let G=D.equations[Y];r.addEquation(G)}}r.solve(e,this),h&&(d.solve=performance.now()-u),r.removeAllEquations();let X=Math.pow;for(x=0;x!==o;x++){let Q=n[x];if(Q.type&p){let K=X(1-Q.linearDamping,e),Z=Q.velocity;Z.scale(K,Z);let J=Q.angularVelocity;if(J){let ee=X(1-Q.angularDamping,e);J.scale(ee,J)}}}this.dispatchEvent(World_step_preStepEvent),h&&(u=performance.now());let et=this.stepnumber,ei=et%(this.quatNormalizeSkip+1)==0,es=this.quatNormalizeFast;for(x=0;x!==o;x++)n[x].integrate(e,ei,es);this.clearForces(),this.broadphase.dirty=!0,h&&(d.integrate=performance.now()-u),this.stepnumber+=1,this.dispatchEvent(World_step_postStepEvent);let eo=!0;if(this.allowSleep)for(x=0,eo=!1;x!==o;x++){let en=n[x];en.sleepTick(this.time),en.sleepState!==Body.SLEEPING&&(eo=!0)}this.hasActiveBodies=eo}emitContactEvents(){let e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(additions,removals),e){for(let i=0,s=additions.length;i<s;i+=2)beginContactEvent.bodyA=this.getBodyById(additions[i]),beginContactEvent.bodyB=this.getBodyById(additions[i+1]),this.dispatchEvent(beginContactEvent);beginContactEvent.bodyA=beginContactEvent.bodyB=null}if(t){for(let o=0,n=removals.length;o<n;o+=2)endContactEvent.bodyA=this.getBodyById(removals[o]),endContactEvent.bodyB=this.getBodyById(removals[o+1]),this.dispatchEvent(endContactEvent);endContactEvent.bodyA=endContactEvent.bodyB=null}additions.length=removals.length=0;let r=this.hasAnyEventListener("beginShapeContact"),l=this.hasAnyEventListener("endShapeContact");if((r||l)&&this.shapeOverlapKeeper.getDiff(additions,removals),r){for(let h=0,d=additions.length;h<d;h+=2){let p=this.getShapeById(additions[h]),u=this.getShapeById(additions[h+1]);beginShapeContactEvent.shapeA=p,beginShapeContactEvent.shapeB=u,p&&(beginShapeContactEvent.bodyA=p.body),u&&(beginShapeContactEvent.bodyB=u.body),this.dispatchEvent(beginShapeContactEvent)}beginShapeContactEvent.bodyA=beginShapeContactEvent.bodyB=beginShapeContactEvent.shapeA=beginShapeContactEvent.shapeB=null}if(l){for(let m=0,v=removals.length;m<v;m+=2){let $=this.getShapeById(removals[m]),y=this.getShapeById(removals[m+1]);endShapeContactEvent.shapeA=$,endShapeContactEvent.shapeB=y,$&&(endShapeContactEvent.bodyA=$.body),y&&(endShapeContactEvent.bodyB=y.body),this.dispatchEvent(endShapeContactEvent)}endShapeContactEvent.bodyA=endShapeContactEvent.bodyB=endShapeContactEvent.shapeA=endShapeContactEvent.shapeB=null}}clearForces(){let e=this.bodies,t=e.length;for(let i=0;i!==t;i++){let s=e[i];s.force,s.torque,s.force.set(0,0,0),s.torque.set(0,0,0)}}}new AABB;let tmpRay=new Ray,performance=globalThis.performance||{};if(!performance.now){let e=Date.now();performance.timing&&performance.timing.navigationStart&&(e=performance.timing.navigationStart),performance.now=()=>Date.now()-e}new Vec3;let World_step_postStepEvent={type:"postStep"},World_step_preStepEvent={type:"preStep"},World_step_collideEvent={type:Body.COLLIDE_EVENT_NAME,body:null,contact:null},World_step_oldContacts=[],World_step_frictionEquationPool=[],World_step_p1=[],World_step_p2=[],additions=[],removals=[],beginContactEvent={type:"beginContact",bodyA:null,bodyB:null},endContactEvent={type:"endContact",bodyA:null,bodyB:null},beginShapeContactEvent={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},endShapeContactEvent={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};export{AABB,ArrayCollisionMatrix,BODY_SLEEP_STATES,BODY_TYPES,Body,Box,Broadphase,COLLISION_TYPES,ConeTwistConstraint,Constraint,ContactEquation,ContactMaterial,ConvexPolyhedron,Cylinder,DistanceConstraint,Equation,EventTarget,FrictionEquation,GSSolver,GridBroadphase,Heightfield,HingeConstraint,JacobianElement,LockConstraint,Mat3,Material,NaiveBroadphase,Narrowphase,ObjectCollisionMatrix,Particle,Plane,PointToPointConstraint,Pool,Quaternion,RAY_MODES,Ray,RaycastResult,RaycastVehicle,RigidVehicle,RotationalEquation,RotationalMotorEquation,SAPBroadphase,SHAPE_TYPES,SPHSystem,Shape,Solver,Sphere,SplitSolver,Spring,Transform,Trimesh,Vec3,Vec3Pool,WheelInfo,World};